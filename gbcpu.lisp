

;(defpackage :clboy
;  (:use :common-lisp))

;(in-package :clboy)


(defstruct gbcpu
  (a 0 :type (unsigned-byte 8))
  (b 0 :type (unsigned-byte 8))
  (c 0 :type (unsigned-byte 8))
  (d 0 :type (unsigned-byte 8))
  (e 0 :type (unsigned-byte 8))
  (h 0 :type (unsigned-byte 8))
  (l 0 :type (unsigned-byte 8))
  (pc 0 :type (unsigned-byte 16))
  (sp 0 :type (unsigned-byte 16))
  flags)

(defstruct gbflags
  (z 0 :type (unsigned-byte 1))
  (n 0 :type (unsigned-byte 1))
  (h 0 :type (unsigned-byte 1))
  (c 0 :type (unsigned-byte 1)))

(defstruct instruction
  (opcode #x00)
  (bytes 1)
  (cycles 1)
  (asm '(:nop))
  (fun '(or function null)))

(defparameter memory (make-array #x10000 :initial-element 0 :element-type '(unsigned-byte 8)))
(defun read-rom-data-from-file (filename) (with-open-file (bin filename :element-type '(unsigned-byte 8))
  (loop for b = (read-byte bin nil)
        while b collect b)))

(defun replace-memory-with-rom (file) (replace memory (read-rom-data-from-file file)))

(defun default-cpu () (make-gbcpu :flags (make-gbflags)))

;; TODO for half carry during additions we know that if the bottom nibble is less than either
;; argument then we had a half carry. It could ADC also if we added the carry to the lesser arg.
(defun set-flags-for-result (flags res)
  (setf (gbflags-z flags) (if (= res #x00) #x01 #x00)
        (gbflags-c flags) (if (> res #xff) #x01 #x00)))

(defun write-memory-at-addr (addr val)
  (setf (aref memory addr) val))

(defun get-address-from-memory (memory pc)
  (let* ((lsb (aref memory pc))
    (msb (aref memory (+ pc 1))))
    (logior lsb (ash msb 8))))

(defun get-address-from-reg-pair (msb lsb)
    (logior lsb (ash msb 8)))


(defun get-byte-from-hl-address (cpu)
  (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
    (aref memory addr)))

(defun set-reg-pair-bc-to-val (cpu val)
  (setf (gbcpu-b cpu) (logand (ash val -8) #xff)
        (gbcpu-c cpu) (logand val #xff)))
(defun set-reg-pair-de-to-val (cpu val)
  (setf (gbcpu-d cpu) (logand (ash val -8) #xff)
        (gbcpu-e cpu) (logand val #xff)))
(defun set-reg-pair-hl-to-val (cpu val)
  (setf (gbcpu-h cpu) (logand (ash val -8) #xff)
        (gbcpu-l cpu) (logand val #xff)))
(defun set-reg-pair-af-to-val (cpu val)
  (setf (gbcpu-a cpu) (logand (ash val -8) #xff)
        (gbcpu-flags cpu) (flags-from-byte (logand val #xff))))

(defun incr-reg (cpu acc)
  (let ((res (logand (+ (funcall acc cpu) 1) #xff)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) (if (= (logand #x0f res) #x0) #x01 #x00))
    res))
(defun decr-reg (cpu acc)
  (let* ((reg (funcall acc cpu))
         (res (if (= reg 0) 255 (- reg 1))))
    (format t "~A - 1 = ~A~%" reg res)
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 1
          (gbflags-h (gbcpu-flags cpu)) (if (= (logand #x0f res) #xf) #x01 #x00))
    res))

(defun incr-reg-pair (msb lsb)
    (let ((res (+ (logior lsb (ash msb 8)) 1)))
      res))
(defun decr-reg-pair (msb lsb)
    (let ((res (- (logior lsb (ash msb 8)) 1)))
      res))

(defun get-new-addr-from-relative (addr b)
  (let ((rel (if (< b 128)
               b
               (logior b (- (mask-field (byte 1 7) #xFF))))))
    (format t "~X + ~X(~X) ~%" addr rel b)
    (+ addr rel)))

(defun add-signed-byte-to-sp (cpu b)
  (let* ((sp (gbcpu-sp cpu))
         (res (get-new-addr-from-relative sp b)))
    (setf (gbflags-z (gbcpu-flags cpu)) #x00
          (gbflags-n (gbcpu-flags cpu)) #x00
          (gbflags-h (gbcpu-flags cpu)) (if (<= (logand res #x0f) (logand b #x0f)) #x01 #x00)
          (gbflags-c (gbcpu-flags cpu)) (if (> res #xff) #x01 #x00))
    (logand res #xffff)))

(defun and-op (cpu val1 val2)
  (let ((res (logand val1 val2)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 1
          (gbflags-c (gbcpu-flags cpu)) 0)
    res))
(defun or-op (cpu val1 val2)
  (let ((res (logior val1 val2)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 0
          (gbflags-c (gbcpu-flags cpu)) 0)
    res))
(defun xor (cpu val1 val2)
  (let ((res (logxor val1 val2)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 0
          (gbflags-c (gbcpu-flags cpu)) 0)
    res))

(defun add16 (cpu val1 val2)
  (let ((res (+ val1 val2)))
    (setf (gbflags-n (gbcpu-flags cpu)) #x00
          (gbflags-h (gbcpu-flags cpu)) (if (<= (logand #x0f res) (logand #x0f val1)) #x01 #x00)
          (gbflags-c (gbcpu-flags cpu)) (if (> res #xff) #x01 #x00))
    (logand res #xffff)))

(defun add (cpu val1 val2)
  (let ((res (+ val1 val2)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= (logand res #xff) #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) #x00
          (gbflags-h (gbcpu-flags cpu)) (if (<= (logand #x0f res) (logand #x0f val1)) #x01 #x00)
          (gbflags-c (gbcpu-flags cpu)) (if (> res #xff) #x01 #x00))
    (logand res #xff)))
(defun adc (cpu val1 val2)
  (let ((res (+ val1 val2 (gbflags-c (gbcpu-flags cpu)))))
    (format t "~A + ~A + ~A~%" val1 val2 (gbflags-c (gbcpu-flags cpu)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= (logand res #xff) #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) #x00
          (gbflags-h (gbcpu-flags cpu)) (if (<= (logand #x0f res) (logand #x0f val1)) #x01 #x00)
          (gbflags-c (gbcpu-flags cpu)) (if (> res #xff) #x01 #x00))
    (logand res #xff)))

(defun sub (cpu val1 val2)
  (let ((res (if (< val1 val2) (- (+ val1 #x100) val2) (- val1 val2))))
    (format t "~A - ~A~%" val1 val2)
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 1
          (gbflags-h (gbcpu-flags cpu)) (if (< (logand #x0f val1) (logand #x0f val2)) #x01 #x00)
          (gbflags-c (gbcpu-flags cpu)) (if (< val1 val2) #x01 #x00))
    (logand res #xff)))
(defun sbc (cpu val1 val2)
  (let* ((carry (gbflags-c (gbcpu-flags cpu)))
         (res (if (< val1 (+ val2 carry)) (- (+ val1 #x100) (+ val2 carry)) (- val1 (+ val2 carry)))))
    (format t "~A - ~A~%" val1 val2)
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 1
          (gbflags-h (gbcpu-flags cpu)) (if (< (logand #x0f val1) (logand #x0f val2)) #x01 #x00)
          (gbflags-c (gbcpu-flags cpu)) (if (< val1 val2) #x01 #x00))
    (logand res #xff)))


(defun do-call-at-addr (cpu addr)
  (push-addr-on-stack cpu (gbcpu-pc cpu))
  (setf (gbcpu-pc cpu) addr))

(defun do-ret (cpu)
  (let ((addr (pop-addr-from-stack cpu)))
    (setf (gbcpu-pc cpu) addr)))

(defun flags-into-byte (flags)
  (logior
    (ash (gbflags-c flags) 4)
    (ash (gbflags-h flags) 5)
    (ash (gbflags-n flags) 6)
    (ash (gbflags-z flags) 7)))

(defun flags-from-byte (val)
  (make-gbflags :c (logand (ash val -4) #x01)
    :h  (logand (ash val -5) #x01)
    :n  (logand (ash val -6) #x01)
    :z  (logand (ash val -7) #x01)))

(defun push-addr-on-stack (cpu addr)
  (let ((sp (gbcpu-sp cpu))
        (lsb (logand addr #xff))
        (msb (logand (ash addr -8) #xff)))
    (decf (gbcpu-sp cpu) 2)
    (write-memory-at-addr (- sp 1) msb)
    (write-memory-at-addr (- sp 2) lsb)))
(defun pop-addr-from-stack (cpu)
  (let* ((sp (gbcpu-sp cpu))
        (lsb (aref memory sp))
        (msb (aref memory (+ sp 1))))
    (incf (gbcpu-sp cpu) 2)
    (logior lsb (ash msb 8))))

(defun push-reg-pair-on-stack (cpu reg1 reg2)
  (let ((sp (gbcpu-sp cpu)))
    (decf (gbcpu-sp cpu) 2)
    (write-memory-at-addr (- sp 1) reg1)
    (write-memory-at-addr (- sp 2) reg2)))


(defparameter ops (make-array #x100 :initial-element nil))
(defparameter cb-ops (make-array #x100 :initial-element nil))

(setf (aref ops #x00) (make-instruction :opcode #x00 :bytes 1 :cycles 4 :asm '(:nop)
                                        :fun (lambda (cpu) (incf (gbcpu-pc cpu)))))
(setf (aref ops #x01) (make-instruction :opcode #x01 :bytes 3 :cycles 12 :asm '(:ld "BC,u16")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (set-reg-pair-bc-to-val cpu addr)
                                                  (incf (gbcpu-pc cpu) 3)))))
(setf (aref ops #x03) (make-instruction :opcode #x03 :bytes 1 :cycles 8 :asm '(:inc "BC")
                                        :fun (lambda (cpu)
                                                  (set-reg-pair-bc-to-val cpu (incr-reg-pair (gbcpu-b cpu) (gbcpu-c cpu)))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x04) (make-instruction :opcode #x04 :bytes 1 :cycles 4 :asm '(:inc "B")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-b cpu) (incr-reg cpu #'gbcpu-b))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x05) (make-instruction :opcode #x05 :bytes 1 :cycles 4 :asm '(:dec "B")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-b cpu) (decr-reg cpu #'gbcpu-b))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x06) (make-instruction :opcode #x06 :bytes 2 :cycles 8 :asm '(:ld "B,u8")
                                        :fun (lambda (cpu)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-b cpu) b)
                                                  (incf (gbcpu-pc cpu) 2)))))
(setf (aref ops #x08) (make-instruction :opcode #x08 :bytes 3 :cycles 20 :asm '(:ld "(u16),SP")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (write-memory-at-addr addr (logand (gbcpu-sp cpu) #xff))
                                                  (write-memory-at-addr (+ addr 1) (logand (ash (gbcpu-sp cpu) -8) #xff))
                                                  (incf (gbcpu-pc cpu) 3)))))
(setf (aref ops #x09) (make-instruction :opcode #x09 :bytes 1 :cycles 8 :asm '(:add "HL,BC")
                                        :fun (lambda (cpu)
                                                (set-reg-pair-hl-to-val
                                                  cpu (add16 cpu
                                                             (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))
                                                             (get-address-from-reg-pair (gbcpu-b cpu) (gbcpu-c cpu))))
                                                (incf (gbcpu-pc cpu)))))
(setf (aref ops #x0b) (make-instruction :opcode #x0b :bytes 1 :cycles 8 :asm '(:inc "BC")
                                        :fun (lambda (cpu)
                                                  (set-reg-pair-bc-to-val cpu (decr-reg-pair (gbcpu-b cpu) (gbcpu-c cpu)))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x0c) (make-instruction :opcode #x0c :bytes 1 :cycles 4 :asm '(:inc "C")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-c cpu) (incr-reg cpu #'gbcpu-c))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x0d) (make-instruction :opcode #x0d :bytes 1 :cycles 4 :asm '(:dec "C")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-c cpu) (decr-reg cpu #'gbcpu-c))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x0e) (make-instruction :opcode #x0e :bytes 2 :cycles 8 :asm '(:ld "C,u8")
                                        :fun (lambda (cpu)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-c cpu) b)
                                                  (incf (gbcpu-pc cpu) 2)))))

(setf (aref ops #x10) (make-instruction :opcode #x10 :bytes 1 :cycles 4 :asm '(:stop)
                                        :fun (lambda (cpu) (incf (gbcpu-pc cpu)))))
(setf (aref ops #x11) (make-instruction :opcode #x11 :bytes 3 :cycles 12 :asm '(:ld "DE,u16")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (set-reg-pair-de-to-val cpu addr)
                                                  (incf (gbcpu-pc cpu) 3)))))
(setf (aref ops #x12) (make-instruction :opcode #x12 :bytes 1 :cycles 8 :asm '(:ld "(DE),A")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-d cpu) (gbcpu-e cpu))))
                                                  (write-memory-at-addr addr (gbcpu-a cpu))
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #x13) (make-instruction :opcode #x13 :bytes 1 :cycles 8 :asm '(:inc "DE")
                                        :fun (lambda (cpu)
                                                  (set-reg-pair-de-to-val cpu (incr-reg-pair (gbcpu-d cpu) (gbcpu-e cpu)))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x14) (make-instruction :opcode #x14 :bytes 1 :cycles 4 :asm '(:inc "D")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-d cpu) (incr-reg cpu #'gbcpu-d))
                                                  (incf (gbcpu-pc cpu)))))

(setf (aref ops #x15) (make-instruction :opcode #x15 :bytes 1 :cycles 4 :asm '(:dec "D")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-d cpu) (decr-reg cpu #'gbcpu-d))
                                                  (incf (gbcpu-pc cpu)))))

(setf (aref ops #x16) (make-instruction :opcode #x16 :bytes 2 :cycles 8 :asm '(:ld "D,u8")
                                        :fun (lambda (cpu)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-d cpu) b)
                                                  (incf (gbcpu-pc cpu) 2)))))

(setf (aref ops #x17) (make-instruction :opcode #x17 :bytes 1 :cycles 4 :asm '(:rla)
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-a cpu ) (rot-left-reg cpu (gbcpu-a cpu)))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x18) (make-instruction :opcode #x18 :bytes 2 :cycles 12 :asm '(:jr "i8")
                                        :fun (lambda (cpu)
                                                (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                       (addr (get-new-addr-from-relative (+ (gbcpu-pc cpu) 2) b)))
                                                    (setf (gbcpu-pc cpu) addr)))))
(setf (aref ops #x19) (make-instruction :opcode #x19 :bytes 1 :cycles 8 :asm '(:add "HL,DE")
                                        :fun (lambda (cpu)
                                                (set-reg-pair-hl-to-val
                                                  cpu (add16 cpu
                                                             (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))
                                                             (get-address-from-reg-pair (gbcpu-d cpu) (gbcpu-e cpu))))
                                                (incf (gbcpu-pc cpu)))))
(setf (aref ops #x1a)
      (make-instruction
        :opcode #x1a :bytes 1 :cycles 8 :asm '(:ld "A,(DE)")
        :fun (lambda (cpu)
                (let* ((addr (get-address-from-reg-pair (gbcpu-d cpu) (gbcpu-e cpu)))
                      (val (aref memory addr)))
                  (setf (gbcpu-a cpu) val)
                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #x1b) (make-instruction :opcode #x1b :bytes 1 :cycles 8 :asm '(:inc "DE")
                                        :fun (lambda (cpu)
                                                  (set-reg-pair-de-to-val cpu (decr-reg-pair (gbcpu-d cpu) (gbcpu-e cpu)))
                                                  (incf (gbcpu-pc cpu)))))

(setf (aref ops #x1c) (make-instruction :opcode #x1c :bytes 1 :cycles 4 :asm '(:inc "E")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-e cpu) (incr-reg cpu #'gbcpu-e))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x1d) (make-instruction :opcode #x1d :bytes 1 :cycles 4 :asm '(:dec "E")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-e cpu) (decr-reg cpu #'gbcpu-e))
                                                  (incf (gbcpu-pc cpu)))))

(setf (aref ops #x1e) (make-instruction :opcode #x1e :bytes 2 :cycles 8 :asm '(:ld "E,u8")
                                        :fun (lambda (cpu)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-e cpu) b)
                                                  (incf (gbcpu-pc cpu) 2)))))
(setf (aref ops #x1f) (make-instruction :opcode #x1f :bytes 1 :cycles 4 :asm '(:rra)
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-a cpu ) (rot-right-reg cpu (gbcpu-a cpu)))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x20) (make-instruction :opcode #x20 :bytes 2 :cycles 8 :asm '(:jr "NZ,i8")
                                        :fun (lambda (cpu)
                                                (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                       (addr (get-new-addr-from-relative (+ (gbcpu-pc cpu) 2) b)))
                                                  (if (= (gbflags-z (gbcpu-flags cpu)) #x00)
                                                    (setf (gbcpu-pc cpu) addr)
                                                    (incf (gbcpu-pc cpu) 2))))))
(setf (aref ops #x21) (make-instruction :opcode #x21 :bytes 3 :cycles 12 :asm '(:ld "HL,u16")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (set-reg-pair-hl-to-val cpu addr)
                                                  (incf (gbcpu-pc cpu) 3)))))
(setf (aref ops #x22) (make-instruction :opcode #x22 :bytes 1 :cycles 8 :asm '(:ld "(HL+),A")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-a cpu))
                                                  (set-reg-pair-hl-to-val cpu (incr-reg-pair (gbcpu-h cpu) (gbcpu-l cpu)))
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #x23) (make-instruction :opcode #x23 :bytes 1 :cycles 8 :asm '(:inc "HL")
                                        :fun (lambda (cpu)
                                                  (set-reg-pair-hl-to-val cpu (incr-reg-pair (gbcpu-h cpu) (gbcpu-l cpu)))
                                                  (incf (gbcpu-pc cpu)))))

(setf (aref ops #x24) (make-instruction :opcode #x24 :bytes 1 :cycles 4 :asm '(:inc "H")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-h cpu) (incr-reg cpu #'gbcpu-h))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x25) (make-instruction :opcode #x25 :bytes 1 :cycles 4 :asm '(:dec "H")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-h cpu) (decr-reg cpu #'gbcpu-h))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x26) (make-instruction :opcode #x26 :bytes 2 :cycles 8 :asm '(:ld "H,u8")
                                        :fun (lambda (cpu)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-h cpu) b)
                                                  (incf (gbcpu-pc cpu) 2)))))

(setf (aref ops #x28) (make-instruction :opcode #x28 :bytes 2 :cycles 8 :asm '(:jr "Z,i8")
                                        :fun (lambda (cpu)
                                                (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                       (addr (get-new-addr-from-relative (+ (gbcpu-pc cpu) 2) b)))
                                                  (if (= (gbflags-z (gbcpu-flags cpu)) #x01)
                                                    (setf (gbcpu-pc cpu) addr)
                                                    (incf (gbcpu-pc cpu) 2))))))
(setf (aref ops #x29) (make-instruction :opcode #x29 :bytes 1 :cycles 8 :asm '(:add "HL,HL")
                                        :fun (lambda (cpu)
                                                (set-reg-pair-hl-to-val
                                                  cpu (add16 cpu
                                                             (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))
                                                             (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                (incf (gbcpu-pc cpu)))))
(setf (aref ops #x2a) (make-instruction :opcode #x2a :bytes 1 :cycles 8 :asm '(:ld "A,(HL+)")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-a cpu) (get-byte-from-hl-address cpu))
                                                  (set-reg-pair-hl-to-val cpu (incr-reg-pair (gbcpu-h cpu) (gbcpu-l cpu)))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x2b) (make-instruction :opcode #x2b :bytes 1 :cycles 8 :asm '(:inc "HL")
                                        :fun (lambda (cpu)
                                                  (set-reg-pair-hl-to-val cpu (decr-reg-pair (gbcpu-h cpu) (gbcpu-l cpu)))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x2c) (make-instruction :opcode #x2c :bytes 1 :cycles 4 :asm '(:inc "L")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-l cpu) (incr-reg cpu #'gbcpu-l))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x2d) (make-instruction :opcode #x2d :bytes 1 :cycles 4 :asm '(:dec "L")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-l cpu) (decr-reg cpu #'gbcpu-l))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x2e) (make-instruction :opcode #x2e :bytes 2 :cycles 8 :asm '(:ld "L,u8")
                                        :fun (lambda (cpu)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-l cpu) b)
                                                  (incf (gbcpu-pc cpu) 2)))))

(setf (aref ops #x30) (make-instruction :opcode #x30 :bytes 2 :cycles 8 :asm '(:jr "NC,i8")
                                        :fun (lambda (cpu)
                                                (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                       (addr (get-new-addr-from-relative (+ (gbcpu-pc cpu) 2) b)))
                                                  (incf (gbcpu-pc cpu) 2)
                                                  (if (= (gbflags-c (gbcpu-flags cpu)) #x00)
                                                    (setf (gbcpu-pc cpu) addr))))))
(setf (aref ops #x31) (make-instruction :opcode #x31 :bytes 3 :cycles 12 :asm '(:ld "SP,u16")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-sp cpu) addr)
                                                  (incf (gbcpu-pc cpu) 3)))))
(setf (aref ops #x32) (make-instruction :opcode #x32 :bytes 1 :cycles 8 :asm '(:ld "(HL-),A")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-a cpu))
                                                  (set-reg-pair-hl-to-val cpu (decr-reg-pair (gbcpu-h cpu) (gbcpu-l cpu)))
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #x33) (make-instruction :opcode #x33 :bytes 1 :cycles 8 :asm '(:inc "SP")
                                        :fun (lambda (cpu)
                                               (let ((res (logand (+ (gbcpu-sp cpu) 1) #xffff)))
                                                  (setf (gbcpu-sp cpu) res)
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #x35) (make-instruction :opcode #x35 :bytes 1 :cycles 12 :asm '(:dec "(HL)")
                                        :fun (lambda (cpu)
                                                  (setf
                                                    (aref memory (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu)))
                                                    (decr-reg cpu #'get-byte-from-hl-address))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x36) (make-instruction :opcode #x36 :bytes 2 :cycles 12 :asm '(:ld "(HL),u8")
                                        :fun (lambda (cpu)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                      (addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr b)
                                                  (incf (gbcpu-pc cpu) 2)))))
(setf (aref ops #x38) (make-instruction :opcode #x38 :bytes 2 :cycles 8 :asm '(:jr "C,i8")
                                        :fun (lambda (cpu)
                                                (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                       (addr (get-new-addr-from-relative (+ (gbcpu-pc cpu) 2) b)))
                                                  (if (= (gbflags-c (gbcpu-flags cpu)) #x01)
                                                    (setf (gbcpu-pc cpu) addr)
                                                    (incf (gbcpu-pc cpu) 2))))))
(setf (aref ops #x39) (make-instruction :opcode #x39 :bytes 1 :cycles 8 :asm '(:add "HL,SP")
                                        :fun (lambda (cpu)
                                                (set-reg-pair-hl-to-val
                                                  cpu (add16 cpu
                                                             (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))
                                                             (gbcpu-sp cpu)))
                                                (incf (gbcpu-pc cpu)))))
(setf (aref ops #x3b) (make-instruction :opcode #x3b :bytes 1 :cycles 8 :asm '(:dec "SP")
                                        :fun (lambda (cpu)
                                               (let ((res (logand (- (gbcpu-sp cpu) 1) #xffff)))
                                                  (setf (gbcpu-sp cpu) res)
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #x3c) (make-instruction :opcode #x3c :bytes 1 :cycles 4 :asm '(:inc "A")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-a cpu) (incr-reg cpu #'gbcpu-a))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x3d) (make-instruction :opcode #x3d :bytes 1 :cycles 4 :asm '(:dec "A")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-a cpu) (decr-reg cpu #'gbcpu-a))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x3e) (make-instruction :opcode #x3e :bytes 2 :cycles 8 :asm '(:ld "A,u8")
                                        :fun (lambda (cpu)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-a cpu) b)
                                                  (incf (gbcpu-pc cpu) 2)))))

;; Load Block

;; Load Into B
(setf (aref ops #x40) (make-instruction :opcode #x40 :bytes 1 :cycles 4 :asm '(:ld "B,B")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-b cpu) (gbcpu-b cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x41) (make-instruction :opcode #x41 :bytes 1 :cycles 4 :asm '(:ld "B,C")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-b cpu) (gbcpu-c cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x42) (make-instruction :opcode #x42 :bytes 1 :cycles 4 :asm '(:ld "B,D")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-b cpu) (gbcpu-d cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x43) (make-instruction :opcode #x43 :bytes 1 :cycles 4 :asm '(:ld "B,E")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-b cpu) (gbcpu-e cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x44) (make-instruction :opcode #x44 :bytes 1 :cycles 4 :asm '(:ld "B,H")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-b cpu) (gbcpu-h cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x45) (make-instruction :opcode #x45 :bytes 1 :cycles 4 :asm '(:ld "B,L")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-b cpu) (gbcpu-l cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x46) (make-instruction :opcode #x46 :bytes 1 :cycles 8 :asm '(:ld "B,(HL)")
                                        :fun (lambda (cpu)
                                                 (setf (gbcpu-b cpu) (get-byte-from-hl-address cpu))
                                                 (incf (gbcpu-pc cpu)))))
(setf (aref ops #x47) (make-instruction :opcode #x47 :bytes 1 :cycles 4 :asm '(:ld "B,A")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-b cpu) (gbcpu-a cpu))
                                               (incf (gbcpu-pc cpu)))))

;; Load Into C
(setf (aref ops #x48) (make-instruction :opcode #x48 :bytes 1 :cycles 4 :asm '(:ld "C,B")
                                        :fun (lambda (cpu)
                                                 (setf (gbcpu-c cpu) (gbcpu-b cpu))
                                                 (incf (gbcpu-pc cpu)))))
(setf (aref ops #x49) (make-instruction :opcode #x49 :bytes 1 :cycles 4 :asm '(:ld "C,C")
                                        :fun (lambda (cpu)
                                                 (setf (gbcpu-c cpu) (gbcpu-c cpu))
                                                 (incf (gbcpu-pc cpu)))))
(setf (aref ops #x4a) (make-instruction :opcode #x4a :bytes 1 :cycles 4 :asm '(:ld "C,D")
                                        :fun (lambda (cpu)
                                                 (setf (gbcpu-c cpu) (gbcpu-d cpu))
                                                 (incf (gbcpu-pc cpu)))))
(setf (aref ops #x4b) (make-instruction :opcode #x4b :bytes 1 :cycles 4 :asm '(:ld "C,E")
                                        :fun (lambda (cpu)
                                                 (setf (gbcpu-c cpu) (gbcpu-e cpu))
                                                 (incf (gbcpu-pc cpu)))))
(setf (aref ops #x4c) (make-instruction :opcode #x4c :bytes 1 :cycles 4 :asm '(:ld "C,H")
                                        :fun (lambda (cpu)
                                                 (setf (gbcpu-c cpu) (gbcpu-h cpu))
                                                 (incf (gbcpu-pc cpu)))))
(setf (aref ops #x4d) (make-instruction :opcode #x4d :bytes 1 :cycles 4 :asm '(:ld "C,L")
                                        :fun (lambda (cpu)
                                                 (setf (gbcpu-c cpu) (gbcpu-l cpu))
                                                 (incf (gbcpu-pc cpu)))))
(setf (aref ops #x4e) (make-instruction :opcode #x4e :bytes 1 :cycles 8 :asm '(:ld "C,(HL)")
                                        :fun (lambda (cpu)
                                                 (setf (gbcpu-c cpu) (get-byte-from-hl-address cpu))
                                                 (incf (gbcpu-pc cpu)))))
(setf (aref ops #x4f) (make-instruction :opcode #x4f :bytes 1 :cycles 4 :asm '(:ld "C,A")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-c cpu) (gbcpu-a cpu))
                                                  (incf (gbcpu-pc cpu)))))

;; Load Into D
(setf (aref ops #x50) (make-instruction :opcode #x50 :bytes 1 :cycles 4 :asm '(:ld "D,B")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-d cpu) (gbcpu-b cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x51) (make-instruction :opcode #x51 :bytes 1 :cycles 4 :asm '(:ld "D,C")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-d cpu) (gbcpu-c cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x52) (make-instruction :opcode #x52 :bytes 1 :cycles 4 :asm '(:ld "D,D")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-d cpu) (gbcpu-d cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x53) (make-instruction :opcode #x53 :bytes 1 :cycles 4 :asm '(:ld "D,E")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-d cpu) (gbcpu-e cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x54) (make-instruction :opcode #x54 :bytes 1 :cycles 4 :asm '(:ld "D,H")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-d cpu) (gbcpu-h cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x55) (make-instruction :opcode #x55 :bytes 1 :cycles 4 :asm '(:ld "D,L")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-d cpu) (gbcpu-l cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x56) (make-instruction :opcode #x56 :bytes 1 :cycles 8 :asm '(:ld "D,(HL)")
                                        :fun (lambda (cpu)
                                                 (setf (gbcpu-d cpu) (get-byte-from-hl-address cpu))
                                                 (incf (gbcpu-pc cpu)))))
(setf (aref ops #x57) (make-instruction :opcode #x57 :bytes 1 :cycles 4 :asm '(:ld "D,A")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-d cpu) (gbcpu-a cpu))
                                               (incf (gbcpu-pc cpu)))))

;; Load Into E
(setf (aref ops #x58) (make-instruction :opcode #x58 :bytes 1 :cycles 4 :asm '(:ld "E,B")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-e cpu) (gbcpu-b cpu))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x59) (make-instruction :opcode #x59 :bytes 1 :cycles 4 :asm '(:ld "E,C")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-e cpu) (gbcpu-c cpu))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x5a) (make-instruction :opcode #x5a :bytes 1 :cycles 4 :asm '(:ld "E,D")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-e cpu) (gbcpu-d cpu))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x5b) (make-instruction :opcode #x5b :bytes 1 :cycles 4 :asm '(:ld "E,E")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-e cpu) (gbcpu-e cpu))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x5c) (make-instruction :opcode #x5c :bytes 1 :cycles 4 :asm '(:ld "E,H")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-e cpu) (gbcpu-h cpu))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x5d) (make-instruction :opcode #x5d :bytes 1 :cycles 4 :asm '(:ld "E,L")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-e cpu) (gbcpu-l cpu))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x5e) (make-instruction :opcode #x5e :bytes 1 :cycles 8 :asm '(:ld "E,(HL)")
                                        :fun (lambda (cpu)
                                                 (setf (gbcpu-e cpu) (get-byte-from-hl-address cpu))
                                                 (incf (gbcpu-pc cpu)))))
(setf (aref ops #x5f) (make-instruction :opcode #x5f :bytes 1 :cycles 4 :asm '(:ld "E,A")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-e cpu) (gbcpu-a cpu))
                                                  (incf (gbcpu-pc cpu)))))

;; Load Into H
(setf (aref ops #x60) (make-instruction :opcode #x60 :bytes 1 :cycles 4 :asm '(:ld "H,B")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-h cpu) (gbcpu-b cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x61) (make-instruction :opcode #x61 :bytes 1 :cycles 4 :asm '(:ld "H,C")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-h cpu) (gbcpu-c cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x62) (make-instruction :opcode #x62 :bytes 1 :cycles 4 :asm '(:ld "H,D")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-h cpu) (gbcpu-d cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x63) (make-instruction :opcode #x63 :bytes 1 :cycles 4 :asm '(:ld "H,E")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-h cpu) (gbcpu-e cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x64) (make-instruction :opcode #x64 :bytes 1 :cycles 4 :asm '(:ld "H,H")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-h cpu) (gbcpu-h cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x65) (make-instruction :opcode #x65 :bytes 1 :cycles 4 :asm '(:ld "H,L")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-h cpu) (gbcpu-l cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x66) (make-instruction :opcode #x66 :bytes 1 :cycles 8 :asm '(:ld "H,(HL)")
                                        :fun (lambda (cpu)
                                                 (setf (gbcpu-h cpu) (get-byte-from-hl-address cpu))
                                                 (incf (gbcpu-pc cpu)))))
(setf (aref ops #x67) (make-instruction :opcode #x67 :bytes 1 :cycles 4 :asm '(:ld "H,A")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-h cpu) (gbcpu-a cpu))
                                               (incf (gbcpu-pc cpu)))))

;; Load Into L
(setf (aref ops #x68) (make-instruction :opcode #x68 :bytes 1 :cycles 4 :asm '(:ld "L,B")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-l cpu) (gbcpu-b cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x69) (make-instruction :opcode #x69 :bytes 1 :cycles 4 :asm '(:ld "L,C")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-l cpu) (gbcpu-c cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x6a) (make-instruction :opcode #x6a :bytes 1 :cycles 4 :asm '(:ld "L,D")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-l cpu) (gbcpu-d cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x6b) (make-instruction :opcode #x6b :bytes 1 :cycles 4 :asm '(:ld "L,E")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-l cpu) (gbcpu-e cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x6c) (make-instruction :opcode #x6c :bytes 1 :cycles 4 :asm '(:ld "L,H")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-l cpu) (gbcpu-h cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x6d) (make-instruction :opcode #x6d :bytes 1 :cycles 4 :asm '(:ld "L,L")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-l cpu) (gbcpu-l cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x6e) (make-instruction :opcode #x6e :bytes 1 :cycles 8 :asm '(:ld "L,(HL)")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-l cpu) (get-byte-from-hl-address cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x6f) (make-instruction :opcode #x6f :bytes 1 :cycles 4 :asm '(:ld "L,A")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-l cpu) (gbcpu-a cpu))
                                               (incf (gbcpu-pc cpu)))))

;; Load Into (HL)
(setf (aref ops #x70) (make-instruction :opcode #x70 :bytes 1 :cycles 8 :asm '(:ld "(HL),B")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-b cpu))
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #x71) (make-instruction :opcode #x71 :bytes 1 :cycles 8 :asm '(:ld "(HL),C")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-c cpu))
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #x72) (make-instruction :opcode #x72 :bytes 1 :cycles 8 :asm '(:ld "(HL),D")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-d cpu))
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #x73) (make-instruction :opcode #x73 :bytes 1 :cycles 8 :asm '(:ld "(HL),E")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-e cpu))
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #x74) (make-instruction :opcode #x74 :bytes 1 :cycles 8 :asm '(:ld "(HL),H")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-h cpu))
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #x75) (make-instruction :opcode #x75 :bytes 1 :cycles 8 :asm '(:ld "(HL),L")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-l cpu))
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #x77) (make-instruction :opcode #x77 :bytes 1 :cycles 8 :asm '(:ld "(HL),A")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-a cpu))
                                                  (incf (gbcpu-pc cpu))))))

;; Load Into A
(setf (aref ops #x78) (make-instruction :opcode #x78 :bytes 1 :cycles 4 :asm '(:ld "A,B")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-a cpu) (gbcpu-b cpu))
                                                  (incf (gbcpu-pc cpu)))))

(setf (aref ops #x79) (make-instruction :opcode #x79 :bytes 1 :cycles 4 :asm '(:ld "A,C")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-a cpu) (gbcpu-c cpu))
                                                  (incf (gbcpu-pc cpu)))))

(setf (aref ops #x7a) (make-instruction :opcode #x7a :bytes 1 :cycles 4 :asm '(:ld "A,D")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-a cpu) (gbcpu-d cpu))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x7b) (make-instruction :opcode #x7b :bytes 1 :cycles 4 :asm '(:ld "A,E")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-a cpu) (gbcpu-e cpu))
                                                  (incf (gbcpu-pc cpu)))))

(setf (aref ops #x7c) (make-instruction :opcode #x7c :bytes 1 :cycles 4 :asm '(:ld "A,H")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-a cpu) (gbcpu-h cpu))
                                                  (incf (gbcpu-pc cpu)))))

(setf (aref ops #x7d) (make-instruction :opcode #x7d :bytes 1 :cycles 4 :asm '(:ld "A,L")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-a cpu) (gbcpu-l cpu))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #x7e) (make-instruction :opcode #x7e :bytes 1 :cycles 8 :asm '(:ld "A,(HL)")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-a cpu) (get-byte-from-hl-address cpu))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #x7f) (make-instruction :opcode #x7f :bytes 1 :cycles 4 :asm '(:ld "A,A")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-a cpu) (gbcpu-a cpu))
                                                  (incf (gbcpu-pc cpu)))))

;; Arithmentic
;; ADDs

(setf (aref ops #x86) (make-instruction :opcode #x86 :bytes 1 :cycles 8 :asm '(:add "A,(HL)")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-a cpu) (add cpu (gbcpu-a cpu) (get-byte-from-hl-address cpu)))
                                                  (incf (gbcpu-pc cpu)))))

;; SUBs
(setf (aref ops #x90) (make-instruction :opcode #x90 :bytes 1 :cycles 4 :asm '(:sub "A,B")
                                        :fun (lambda (cpu)
                                               (let ((res (sub cpu (gbcpu-a cpu) (gbcpu-b cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incf (gbcpu-pc cpu))))))


;; ANDs

;; XORs
(setf (aref ops #xa9) (make-instruction :opcode #xa9 :bytes 1 :cycles 4 :asm '(:xor "A,C")
                                        :fun (lambda (cpu)
                                               (let ((res (xor cpu (gbcpu-a cpu) (gbcpu-c cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #xad) (make-instruction :opcode #xad :bytes 1 :cycles 4 :asm '(:xor "A,L")
                                        :fun (lambda (cpu)
                                               (let ((res (xor cpu (gbcpu-a cpu) (gbcpu-l cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #xae) (make-instruction :opcode #xae :bytes 1 :cycles 8 :asm '(:xor "A,(HL)")
                                        :fun (lambda (cpu)
                                               (let ((res (xor cpu (gbcpu-a cpu) (get-byte-from-hl-address cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #xaf) (make-instruction :opcode #xaf :bytes 1 :cycles 4 :asm '(:xor "A,A")
                                        :fun (lambda (cpu)
                                               (let ((res (xor cpu (gbcpu-a cpu) (gbcpu-a cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incf (gbcpu-pc cpu))))))


;; ORs
(setf (aref ops #xb0) (make-instruction :opcode #xb0 :bytes 1 :cycles 4 :asm '(:or "A,B")
                                        :fun (lambda (cpu)
                                               (let ((res (or-op cpu (gbcpu-a cpu) (gbcpu-b cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #xb1) (make-instruction :opcode #xb1 :bytes 1 :cycles 4 :asm '(:or "A,C")
                                        :fun (lambda (cpu)
                                               (let ((res (or-op cpu (gbcpu-a cpu) (gbcpu-c cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #xb6) (make-instruction :opcode #xb6 :bytes 1 :cycles 8 :asm '(:or "A,(HL)")
                                        :fun (lambda (cpu)
                                                  (setf (gbcpu-a cpu) (or-op cpu (gbcpu-a cpu) (get-byte-from-hl-address cpu)))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #xb7) (make-instruction :opcode #xb7 :bytes 1 :cycles 4 :asm '(:or "A,A")
                                        :fun (lambda (cpu)
                                               (let ((res (or-op cpu (gbcpu-a cpu) (gbcpu-a cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incf (gbcpu-pc cpu))))))

;; CPs
(setf (aref ops #xbe) (make-instruction :opcode #xbe :bytes 1 :cycles 8 :asm '(:cp "A,(HL)")
                                           :fun (lambda (cpu)
                                                  (cp-reg-with-val cpu (gbcpu-a cpu) (get-byte-from-hl-address cpu))
                                                  (incf (gbcpu-pc cpu)))))

(setf (aref ops #xc1) (make-instruction :opcode #xc1 :bytes 1 :cycles 12 :asm '(:pop "BC")
                                        :fun (lambda (cpu)
                                                  (set-reg-pair-bc-to-val cpu (pop-addr-from-stack cpu))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #xc3) (make-instruction :opcode #xc3 :bytes 3 :cycles 16 :asm '(:jp "u16")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                    (setf (gbcpu-pc cpu) addr)))))
(setf (aref ops #xc4) (make-instruction :opcode #xc4 :bytes 3 :cycles 24 :asm '(:call "NZ,u16")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (incf (gbcpu-pc cpu) 3)
                                                  (if (= (gbflags-z (gbcpu-flags cpu)) #x00)
                                                    (do-call-at-addr cpu addr))))))
(setf (aref ops #xc5) (make-instruction :opcode #xc5 :bytes 1 :cycles 16 :asm '(:push "BC")
                                        :fun (lambda (cpu)
                                                  (push-reg-pair-on-stack cpu (gbcpu-b cpu) (gbcpu-c cpu))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #xc6) (make-instruction :opcode #xc6 :bytes 2 :cycles 8 :asm '(:add "A,u8")
                                        :fun (lambda (cpu)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-a cpu) (add cpu (gbcpu-a cpu) b))
                                                  (incf (gbcpu-pc cpu) 2)))))
(setf (aref ops #xc8) (make-instruction :opcode #xc8 :bytes 1 :cycles 8 :asm '(:ret "Z")
                                        :fun (lambda (cpu)
                                                  (incf (gbcpu-pc cpu))
                                                  (if (= (gbflags-z (gbcpu-flags cpu)) #x01)
                                                    (do-ret cpu)))))
(setf (aref ops #xc9) (make-instruction :opcode #xc9 :bytes 1 :cycles 16 :asm '(:ret)
                                        :fun (lambda (cpu) (do-ret cpu))))
(setf (aref ops #xcd) (make-instruction :opcode #xcd :bytes 3 :cycles 24 :asm '(:call "u16")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (incf (gbcpu-pc cpu) 3)
                                                  (do-call-at-addr cpu addr)))))
(setf (aref ops #xce) (make-instruction :opcode #xce :bytes 2 :cycles 8 :asm '(:adc "A,u8")
                                        :fun (lambda (cpu)
                                               (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                      (res (adc cpu (gbcpu-a cpu) b)))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incf (gbcpu-pc cpu) 2)))))

(setf (aref ops #xd0) (make-instruction :opcode #xd0 :bytes 1 :cycles 8 :asm '(:ret "NC")
                                        :fun (lambda (cpu)
                                                  (incf (gbcpu-pc cpu))
                                                  (if (= (gbflags-c (gbcpu-flags cpu)) #x00)
                                                    (do-ret cpu)))))
(setf (aref ops #xd1) (make-instruction :opcode #xd1 :bytes 1 :cycles 12 :asm '(:pop "DE")
                                        :fun (lambda (cpu)
                                                  (set-reg-pair-de-to-val cpu (pop-addr-from-stack cpu))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #xd5) (make-instruction :opcode #xd5 :bytes 1 :cycles 16 :asm '(:push "DE")
                                        :fun (lambda (cpu)
                                                  (push-reg-pair-on-stack cpu (gbcpu-d cpu) (gbcpu-e cpu))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #xd6) (make-instruction :opcode #xd6 :bytes 2 :cycles 8 :asm '(:sub "A,u8")
                                        :fun (lambda (cpu)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-a cpu) (sub cpu (gbcpu-a cpu) b))
                                                  (incf (gbcpu-pc cpu) 2)))))
(setf (aref ops #xd8) (make-instruction :opcode #xd8 :bytes 1 :cycles 8 :asm '(:ret "C")
                                        :fun (lambda (cpu)
                                                  (incf (gbcpu-pc cpu))
                                                  (if (= (gbflags-c (gbcpu-flags cpu)) #x01)
                                                    (do-ret cpu)))))
(setf (aref ops #xde) (make-instruction :opcode #xde :bytes 2 :cycles 8 :asm '(:sbc "A,u8")
                                        :fun (lambda (cpu)
                                               (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                      (res (sbc cpu (gbcpu-a cpu) b)))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incf (gbcpu-pc cpu) 2)))))

(setf (aref ops #xe0) (make-instruction :opcode #xe0 :bytes 2 :cycles 12 :asm '(:ld "(FF00+u8),A")
                                        :fun (lambda (cpu)
                                                (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                         (addr (+ #xff00 b)))
                                                  (write-memory-at-addr addr (gbcpu-a cpu))
                                                  (incf (gbcpu-pc cpu) 2)))))
(setf (aref ops #xe1) (make-instruction :opcode #xe1 :bytes 1 :cycles 12 :asm '(:pop "HL")
                                        :fun (lambda (cpu)
                                                  (set-reg-pair-hl-to-val cpu (pop-addr-from-stack cpu))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #xe2) (make-instruction :opcode #xe2 :bytes 1 :cycles 8 :asm '(:ld "(FF00+C),A")
                                        :fun (lambda (cpu)
                                                (let ((addr (+ #xff00 (gbcpu-c cpu))))
                                                  (write-memory-at-addr addr (gbcpu-a cpu))
                                                  (incf (gbcpu-pc cpu))))))
(setf (aref ops #xe5) (make-instruction :opcode #xe5 :bytes 1 :cycles 16 :asm '(:push "HL")
                                        :fun (lambda (cpu)
                                                  (push-reg-pair-on-stack cpu (gbcpu-h cpu) (gbcpu-l cpu))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #xe6) (make-instruction :opcode #xe6 :bytes 2 :cycles 8 :asm '(:and "A,u8")
                                        :fun (lambda (cpu)
                                               (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                      (res (and-op cpu (gbcpu-a cpu) b)))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incf (gbcpu-pc cpu) 2)))))
(setf (aref ops #xe8) (make-instruction :opcode #xe8 :bytes 2 :cycles 8 :asm '(:add "SP,i8")
                                        :fun (lambda (cpu)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-sp cpu) (add-signed-byte-to-sp cpu b))
                                                  (incf (gbcpu-pc cpu) 2)))))
(setf (aref ops #xe9) (make-instruction :opcode #xe9 :bytes 1 :cycles 4 :asm '(:jp "HL")
                                        :fun (lambda (cpu)
                                                    (setf (gbcpu-pc cpu) (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))))
(setf (aref ops #xea) (make-instruction :opcode #xea :bytes 3 :cycles 16 :asm '(:ld "(u16),A")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (write-memory-at-addr addr (gbcpu-a cpu))
                                                  (incf (gbcpu-pc cpu) 3)))))
(setf (aref ops #xee) (make-instruction :opcode #xee :bytes 2 :cycles 8 :asm '(:xor "A,u8")
                                        :fun (lambda (cpu)
                                               (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                      (res (xor cpu (gbcpu-a cpu) b)))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incf (gbcpu-pc cpu) 2)))))

(setf (aref ops #xf0) (make-instruction :opcode #xf0 :bytes 2 :cycles 12 :asm '(:ld "A,(FF00+u8)")
                                        :fun (lambda (cpu)
                                                (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                         (addr (+ #xff00 b)))
                                                  (setf (gbcpu-a cpu) (aref memory addr))
                                                  (incf (gbcpu-pc cpu) 2)))))
(setf (aref ops #xf1) (make-instruction :opcode #xf1 :bytes 1 :cycles 12 :asm '(:pop "AF")
                                        :fun (lambda (cpu)
                                                  (set-reg-pair-af-to-val cpu (pop-addr-from-stack cpu))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #xf3) (make-instruction :opcode #xf3 :bytes 1 :cycles 4 :asm '(:DI)
                                        :fun (lambda (cpu) (incf (gbcpu-pc cpu)))))
(setf (aref ops #xf5) (make-instruction :opcode #xf5 :bytes 1 :cycles 16 :asm '(:push "AF")
                                        :fun (lambda (cpu)
                                                  (push-reg-pair-on-stack cpu (gbcpu-a cpu) (flags-into-byte (gbcpu-flags cpu)))
                                                  (incf (gbcpu-pc cpu)))))
(setf (aref ops #xf6) (make-instruction :opcode #xf6 :bytes 2 :cycles 8 :asm '(:or "A,u8")
                                        :fun (lambda (cpu)
                                               (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                      (res (or-op cpu (gbcpu-a cpu) b)))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incf (gbcpu-pc cpu) 2)))))
(setf (aref ops #xf8) (make-instruction :opcode #xf8 :bytes 2 :cycles 8 :asm '(:add "HL,SP+i8")
                                        :fun (lambda (cpu)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (set-reg-pair-hl-to-val cpu (add-signed-byte-to-sp cpu b))
                                                  (incf (gbcpu-pc cpu) 2)))))
(setf (aref ops #xf9) (make-instruction :opcode #xf9 :bytes 1 :cycles 8 :asm '(:ld "SP,HL")
                                        :fun (lambda (cpu)
                                               (setf (gbcpu-sp cpu) (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu)))
                                               (incf (gbcpu-pc cpu)))))
(setf (aref ops #xfa) (make-instruction :opcode #xfa :bytes 3 :cycles 16 :asm '(:ld "A,(u16)")
                                        :fun (lambda (cpu)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-a cpu) (aref memory addr))
                                                  (incf (gbcpu-pc cpu) 3)))))
(setf (aref ops #xfb) (make-instruction :opcode #xfb :bytes 1 :cycles 4 :asm '(:EI)
                                        :fun (lambda (cpu) (incf (gbcpu-pc cpu)))))
(setf (aref ops #xfe) (make-instruction :opcode #xfe :bytes 2 :cycles 8 :asm '(:cp "A,u8")
                                           :fun (lambda (cpu)
                                                  (let ((val (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (cp-reg-with-val cpu (gbcpu-a cpu) val)
                                                  (incf (gbcpu-pc cpu) 2)))))

(defun cp-reg-with-val (cpu reg val)
  (let ((res (- reg val)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 1
          (gbflags-h (gbcpu-flags cpu)) (if (< (logand #x0f reg) (logand #x0f val)) #x01 #x00)
          (gbflags-c (gbcpu-flags cpu)) (if (< reg val) #x01 #x00))
    res))
(defun test-bit-reg (cpu val bit-pos)
  (let ((res (logand val (ash #x01 bit-pos))))
    (incf (gbcpu-pc cpu) 2)
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 1)
    res))
(defun reset-bit-reg (cpu val bit-pos)
  (let ((res (logand val (logxor (ash #x01 bit-pos) #xff))))
    (incf (gbcpu-pc cpu) 2)
    res))
(defun set-bit-reg (cpu val bit-pos)
  (let ((res (logior val (ash #x01 bit-pos))))
    (incf (gbcpu-pc cpu) 2)
    res))

(defun rot-left-reg (cpu val)
  (let ((b7 (logand (ash val -7) #x01))
        (res (logand (logior (ash val 1) (gbflags-c (gbcpu-flags cpu))) #xff)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 0
          (gbflags-c (gbcpu-flags cpu)) b7)
    res))
(defun rot-right-reg (cpu val)
  (let ((b1 (logand val #x01))
        (res (logand (logior (ash val -1) (ash (gbflags-c (gbcpu-flags cpu)) 7)) #xff)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 0
          (gbflags-c (gbcpu-flags cpu)) b1)
    res))

(defun shift-right-into-carry (cpu val)
  (let ((b1 (logand val #x01))
        (res (logand (ash val -1) #xff)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 0
          (gbflags-c (gbcpu-flags cpu)) b1)
    res))

(defun swap-reg (cpu val)
  (let* ((lsb (logand val #xf))
        (msb (logand (ash val -4) #xf))
        (res (logior (ash lsb 4) msb)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 0
          (gbflags-c (gbcpu-flags cpu)) 0)
    res))

;; RLC
(setf (aref cb-ops #x01) (make-instruction :opcode #x01 :bytes 2 :cycles 8 :asm '(:rlc "C")
                                           :fun (lambda (cpu)
                                                  (setf (gbcpu-c cpu ) (rot-left-c-reg cpu (gbcpu-c cpu)))
                                                  (incf (gbcpu-pc cpu) 2))))
;; RRC
(setf (aref cb-ops #x09) (make-instruction :opcode #x09 :bytes 2 :cycles 8 :asm '(:rrc "C")
                                           :fun (lambda (cpu)
                                                  (setf (gbcpu-c cpu ) (rot-right-c-reg cpu (gbcpu-c cpu)))
                                                  (incf (gbcpu-pc cpu) 2))))
;; RL
(setf (aref cb-ops #x11) (make-instruction :opcode #x11 :bytes 2 :cycles 8 :asm '(:rl "C")
                                           :fun (lambda (cpu)
                                                  (setf (gbcpu-c cpu ) (rot-left-reg cpu (gbcpu-c cpu)))
                                                  (incf (gbcpu-pc cpu) 2))))
;; RR
(setf (aref cb-ops #x19) (make-instruction :opcode #x19 :bytes 2 :cycles 8 :asm '(:rr "C")
                                           :fun (lambda (cpu)
                                                  (setf (gbcpu-c cpu ) (rot-right-reg cpu (gbcpu-c cpu)))
                                                  (incf (gbcpu-pc cpu) 2))))
(setf (aref cb-ops #x1a) (make-instruction :opcode #x1a :bytes 2 :cycles 8 :asm '(:rr "D")
                                           :fun (lambda (cpu)
                                                  (setf (gbcpu-d cpu ) (rot-right-reg cpu (gbcpu-d cpu)))
                                                  (incf (gbcpu-pc cpu) 2))))
(setf (aref cb-ops #x1b) (make-instruction :opcode #x1b :bytes 2 :cycles 8 :asm '(:rr "E")
                                           :fun (lambda (cpu)
                                                  (setf (gbcpu-e cpu ) (rot-right-reg cpu (gbcpu-e cpu)))
                                                  (incf (gbcpu-pc cpu) 2))))
;; SLA
(setf (aref cb-ops #x21) (make-instruction :opcode #x21 :bytes 2 :cycles 8 :asm '(:sla "C")
                                           :fun (lambda (cpu)
                                                  (setf (gbcpu-c cpu ) (shift-left-reg cpu (gbcpu-c cpu)))
                                                  (incf (gbcpu-pc cpu) 2))))
;; SRA
(setf (aref cb-ops #x29) (make-instruction :opcode #x29 :bytes 2 :cycles 8 :asm '(:sra "C")
                                           :fun (lambda (cpu)
                                                  (setf (gbcpu-c cpu ) (shift-right-reg cpu (gbcpu-c cpu)))
                                                  (incf (gbcpu-pc cpu) 2))))
;; SWAP
(setf (aref cb-ops #x31) (make-instruction :opcode #x31 :bytes 2 :cycles 8 :asm '(:swap "C")
                                           :fun (lambda (cpu)
                                                  (setf (gbcpu-c cpu ) (swap-reg cpu (gbcpu-c cpu)))
                                                  (incf (gbcpu-pc cpu) 2))))
(setf (aref cb-ops #x37) (make-instruction :opcode #x37 :bytes 2 :cycles 8 :asm '(:swap "(HL)")
                                           :fun (lambda (cpu)
                                                  (set-reg-pair-hl-to-val cpu (swap-reg cpu (get-byte-from-hl-address cpu)))
                                                  (incf (gbcpu-pc cpu) 2))))
;; SRL
(setf (aref cb-ops #x38) (make-instruction :opcode #x38 :bytes 2 :cycles 8 :asm '(:srl "B")
                                           :fun (lambda (cpu)
                                                  (setf (gbcpu-b cpu ) (shift-right-into-carry cpu (gbcpu-b cpu)))
                                                  (incf (gbcpu-pc cpu) 2))))
;; BIT
(setf (aref cb-ops #x7c) (make-instruction :opcode #x7c :bytes 2 :cycles 8 :asm '(:bit "7,H")
                                           :fun (lambda (cpu) (test-bit-reg cpu (gbcpu-h cpu) 7))))
;; RES
(setf (aref cb-ops #x80) (make-instruction :opcode #x80 :bytes 2 :cycles 8 :asm '(:res "0,B")
                                           :fun (lambda (cpu) (reset-bit-reg cpu (gbcpu-b cpu) 0))))
;; SET
(setf (aref cb-ops #xc0) (make-instruction :opcode #xc0 :bytes 2 :cycles 8 :asm '(:bit "0,B")
                                           :fun (lambda (cpu) (set-bit-reg cpu (gbcpu-b cpu) 0))))

(defun get-cb-instruction (cpu)
  (let* ((op (aref memory (+ (gbcpu-pc cpu) 1)))
        (instr (aref cb-ops op)))
      (if (instruction-p instr)
        instr
        (format t "Unimplemented CB instruction ~X @ ~X~%" op (gbcpu-pc cpu)))))

(defun emu-single-op (cpu op)
  (let ((instr (if (= op #xcb) (get-cb-instruction cpu) (aref ops op))))
  (if (instruction-p instr)
    (progn (if (null (instruction-fun instr))
             (format t "Unable to run function for instruction ~X @ ~X~%" op (gbcpu-pc cpu))
             (funcall (instruction-fun instr) cpu))
           instr)
    (format t "Unimplemented instruction ~X @ ~X~%" op (gbcpu-pc cpu)))))

(defun emu-main (cpu)
  (loop for o = (aref memory (gbcpu-pc cpu))
        while (< (gbcpu-pc cpu) #x8000)
        for instr  = (emu-single-op cpu o)
        while instr do (format t "~A --> PC=~X~%" (instruction-asm instr) (gbcpu-pc cpu))))

;(load "gbcpu.lisp")

(defparameter *cpu* (default-cpu))

;(replace-memory-with-rom "red.gb")


;; test rom memory replace calls
;(replace-memory-with-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/01-special.gb")
;(replace-memory-with-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/02-interrupts.gb")
;(replace-memory-with-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/03-op sp,hl.gb")
;(replace-memory-with-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/04-op r,imm.gb")
;(replace-memory-with-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/05-op rp.gb")
;(replace-memory-with-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/06-ld r,r.gb")

;(replace-memory-with-rom "DMG_ROM.bin")

;(setf (aref memory #xff44) #x90)

(defun run () (emu-main *cpu*))

(emu-main *cpu*)

