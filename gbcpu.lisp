

;(defpackage :clboy
;  (:use :common-lisp))

;(in-package :clboy)


(defstruct gbcpu
  (a 0 :type (unsigned-byte 8))
  (b 0 :type (unsigned-byte 8))
  (c 0 :type (unsigned-byte 8))
  (d 0 :type (unsigned-byte 8))
  (e 0 :type (unsigned-byte 8))
  (h 0 :type (unsigned-byte 8))
  (l 0 :type (unsigned-byte 8))
  (pc 0 :type (unsigned-byte 16))
  (sp 0 :type (unsigned-byte 16))
  (clock 0)
  (div-clock 0 :type (unsigned-byte 16))
  (int-ena 0 :type (unsigned-byte 1))
  (halted 0 :type (unsigned-byte 1))
  flags)

(defstruct gbflags
  (z 0 :type (unsigned-byte 1))
  (n 0 :type (unsigned-byte 1))
  (h 0 :type (unsigned-byte 1))
  (c 0 :type (unsigned-byte 1)))

(defstruct instruction
  (opcode #x00)
  (bytes 1)
  (cycles 1)
  (asm '(:nop))
  (fun '(or function null)))

(defparameter memory (make-array #x10000 :initial-element 0 :element-type '(unsigned-byte 8)))
(defun read-rom-data-from-file (filename) (with-open-file (bin filename :element-type '(unsigned-byte 8))
  (loop for b = (read-byte bin nil)
        while b collect b)))

(defun replace-memory-with-rom (file) (replace memory (read-rom-data-from-file file)))

(defun default-cpu () (make-gbcpu :flags (make-gbflags)))

;; TODO for half carry during additions we know that if the bottom nibble is less than either
;; argument then we had a half carry. It could ADC also if we added the carry to the lesser arg.
(defun set-flags-for-result (flags res)
  (setf (gbflags-z flags) (if (= res #x00) #x01 #x00)
        (gbflags-c flags) (if (> res #xff) #x01 #x00)))

(defun write-memory-at-addr (addr val)
  (setf (aref memory addr) val))
(defun read-memory-at-addr (addr)
  (aref memory addr))

(defun get-address-from-memory (memory pc)
  (let* ((lsb (aref memory pc))
    (msb (aref memory (+ pc 1))))
    (logior lsb (ash msb 8))))

(defun get-address-from-reg-pair (msb lsb)
    (logior lsb (ash msb 8)))


(defun get-byte-from-hl-address (cpu)
  (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
    (aref memory addr)))

(defun set-reg-pair-bc-to-val (cpu val)
  (setf (gbcpu-b cpu) (logand (ash val -8) #xff)
        (gbcpu-c cpu) (logand val #xff)))
(defun set-reg-pair-de-to-val (cpu val)
  (setf (gbcpu-d cpu) (logand (ash val -8) #xff)
        (gbcpu-e cpu) (logand val #xff)))
(defun set-reg-pair-hl-to-val (cpu val)
  (setf (gbcpu-h cpu) (logand (ash val -8) #xff)
        (gbcpu-l cpu) (logand val #xff)))
(defun set-reg-pair-af-to-val (cpu val)
  (setf (gbcpu-a cpu) (logand (ash val -8) #xff)
        (gbcpu-flags cpu) (flags-from-byte (logand val #xff))))

(defun incr-reg (cpu acc)
  (let ((res (logand (+ (funcall acc cpu) 1) #xff)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) (if (= (logand #x0f res) #x0) #x01 #x00))
    res))
(defun decr-reg (cpu acc)
  (let* ((reg (funcall acc cpu))
         (res (if (= reg 0) 255 (- reg 1))))
    (format t "~A - 1 = ~A~%" reg res)
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 1
          (gbflags-h (gbcpu-flags cpu)) (if (= (logand #x0f res) #xf) #x01 #x00))
    res))

(defun incr-reg-pair (msb lsb)
    (let ((res (+ (logior lsb (ash msb 8)) 1)))
      res))
(defun decr-reg-pair (msb lsb)
    (let ((res (- (logior lsb (ash msb 8)) 1)))
      res))

(defun incr-cpu-counters (cpu instr)
  (incf (gbcpu-pc cpu) (instruction-bytes instr))
  (incr-clocks cpu instr))
(defun incr-clocks (cpu instr)
  (incf (gbcpu-clock cpu) (* (car (instruction-cycles instr)) 4))
  (incf (gbcpu-div-clock cpu) (car (instruction-cycles instr))))
(defun incr-branched-clocks (cpu instr)
  (incf (gbcpu-clock cpu) (* (cadr (instruction-cycles instr)) 4))
  (incf (gbcpu-div-clock cpu) (cadr (instruction-cycles instr))))

(defun get-new-addr-from-relative (addr b)
  (let ((rel (if (< b 128)
               b
               (logior b (- (mask-field (byte 1 7) #xFF))))))
    (format t "~X + ~X(~X) ~%" addr rel b)
    (+ addr rel)))

(defun add-signed-byte-to-sp (cpu b)
  (let* ((sp (gbcpu-sp cpu))
         (res (get-new-addr-from-relative sp b)))
    (setf (gbflags-z (gbcpu-flags cpu)) #x00
          (gbflags-n (gbcpu-flags cpu)) #x00
          (gbflags-h (gbcpu-flags cpu)) (if (<= (logand res #x0f) (logand b #x0f)) #x01 #x00)
          (gbflags-c (gbcpu-flags cpu)) (if (> res #xff) #x01 #x00))
    (logand res #xffff)))

(defun and-op (cpu val1 val2)
  (let ((res (logand val1 val2)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 1
          (gbflags-c (gbcpu-flags cpu)) 0)
    res))
(defun or-op (cpu val1 val2)
  (let ((res (logior val1 val2)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 0
          (gbflags-c (gbcpu-flags cpu)) 0)
    res))
(defun xor (cpu val1 val2)
  (let ((res (logxor val1 val2)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 0
          (gbflags-c (gbcpu-flags cpu)) 0)
    res))

(defun add16 (cpu val1 val2)
  (let ((res (+ val1 val2)))
    (setf (gbflags-n (gbcpu-flags cpu)) #x00
          (gbflags-h (gbcpu-flags cpu)) (if (<= (logand #xfff res) (logand #xfff val1)) #x01 #x00)
          (gbflags-c (gbcpu-flags cpu)) (if (> res #xffff) #x01 #x00))
    (logand res #xffff)))

(defun add (cpu val1 val2)
  (let ((res (+ val1 val2)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= (logand res #xff) #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) #x00
          (gbflags-h (gbcpu-flags cpu)) (if (<= (logand #x0f res) (logand #x0f val1)) #x01 #x00)
          (gbflags-c (gbcpu-flags cpu)) (if (> res #xff) #x01 #x00))
    (logand res #xff)))
(defun adc (cpu val1 val2)
    (add cpu val1 (+ val2 (gbflags-c (gbcpu-flags cpu)))))

(defun sub (cpu val1 val2)
  (let ((res (if (< val1 val2) (- (+ val1 #x100) val2) (- val1 val2))))
    (format t "~A - ~A~%" val1 val2)
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= (logand res #xff) #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 1
          (gbflags-h (gbcpu-flags cpu)) (if (< (logand #x0f val1) (logand #x0f val2)) #x01 #x00)
          (gbflags-c (gbcpu-flags cpu)) (if (< val1 val2) #x01 #x00))
    (logand res #xff)))
(defun sbc (cpu val1 val2)
    (sub cpu val1 (+ val2 (gbflags-c (gbcpu-flags cpu)))))

(defun cp-reg-with-val (cpu reg val)
  (sub cpu reg val))


(defun do-call-at-addr (cpu addr)
  (push-addr-on-stack cpu (gbcpu-pc cpu))
  (setf (gbcpu-pc cpu) addr))

(defun do-rst (cpu addr)
  (push-addr-on-stack cpu (gbcpu-pc cpu))
  (setf (gbcpu-pc cpu) addr))

(defun do-jump (cpu addr)
  (setf (gbcpu-pc cpu) addr))

(defun do-ret (cpu)
  (let ((addr (pop-addr-from-stack cpu)))
    (setf (gbcpu-pc cpu) addr)))

(defun flags-into-byte (flags)
  (logior
    (ash (gbflags-c flags) 4)
    (ash (gbflags-h flags) 5)
    (ash (gbflags-n flags) 6)
    (ash (gbflags-z flags) 7)))

(defun flags-from-byte (val)
  (make-gbflags :c (logand (ash val -4) #x01)
    :h  (logand (ash val -5) #x01)
    :n  (logand (ash val -6) #x01)
    :z  (logand (ash val -7) #x01)))

(defun push-addr-on-stack (cpu addr)
  (let ((sp (gbcpu-sp cpu))
        (lsb (logand addr #xff))
        (msb (logand (ash addr -8) #xff)))
    (decf (gbcpu-sp cpu) 2)
    (write-memory-at-addr (- sp 1) msb)
    (write-memory-at-addr (- sp 2) lsb)))
(defun pop-addr-from-stack (cpu)
  (let* ((sp (gbcpu-sp cpu))
        (lsb (aref memory sp))
        (msb (aref memory (+ sp 1))))
    (incf (gbcpu-sp cpu) 2)
    (logior lsb (ash msb 8))))

(defun push-reg-pair-on-stack (cpu reg1 reg2)
  (let ((sp (gbcpu-sp cpu)))
    (decf (gbcpu-sp cpu) 2)
    (write-memory-at-addr (- sp 1) reg1)
    (write-memory-at-addr (- sp 2) reg2)))


(defparameter ops (make-array #x100 :initial-element nil))
(defparameter cb-ops (make-array #x100 :initial-element nil))

(setf (aref ops #x00) (make-instruction :opcode #x00 :bytes 1 :cycles '(1 1) :asm '(:nop)
                                        :fun (lambda (cpu instr) (incr-cpu-counters cpu instr))))
(setf (aref ops #x01) (make-instruction :opcode #x01 :bytes 3 :cycles '(3 3) :asm '(:ld "BC,u16")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (set-reg-pair-bc-to-val cpu addr)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x03) (make-instruction :opcode #x03 :bytes 1 :cycles '(2 2) :asm '(:inc "BC")
                                        :fun (lambda (cpu instr)
                                                  (set-reg-pair-bc-to-val cpu (incr-reg-pair (gbcpu-b cpu) (gbcpu-c cpu)))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x04) (make-instruction :opcode #x04 :bytes 1 :cycles '(1 1) :asm '(:inc "B")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-b cpu) (incr-reg cpu #'gbcpu-b))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x05) (make-instruction :opcode #x05 :bytes 1 :cycles '(1 1) :asm '(:dec "B")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-b cpu) (decr-reg cpu #'gbcpu-b))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x06) (make-instruction :opcode #x06 :bytes 2 :cycles '(2 2) :asm '(:ld "B,u8")
                                        :fun (lambda (cpu instr)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-b cpu) b)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x07) (make-instruction :opcode #x07 :bytes 1 :cycles '(1 1) :asm '(:rlca)
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-a cpu ) (rot-left-c-reg cpu (gbcpu-a cpu)))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x08) (make-instruction :opcode #x08 :bytes 3 :cycles '(5 5) :asm '(:ld "(u16),SP")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (write-memory-at-addr addr (logand (gbcpu-sp cpu) #xff))
                                                  (write-memory-at-addr (+ addr 1) (logand (ash (gbcpu-sp cpu) -8) #xff))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x09) (make-instruction :opcode #x09 :bytes 1 :cycles '(2 2) :asm '(:add "HL,BC")
                                        :fun (lambda (cpu instr)
                                                (set-reg-pair-hl-to-val
                                                  cpu (add16 cpu
                                                             (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))
                                                             (get-address-from-reg-pair (gbcpu-b cpu) (gbcpu-c cpu))))
                                                (incr-cpu-counters cpu instr))))
(setf (aref ops #x0b) (make-instruction :opcode #x0b :bytes 1 :cycles '(2 2) :asm '(:inc "BC")
                                        :fun (lambda (cpu instr)
                                                  (set-reg-pair-bc-to-val cpu (decr-reg-pair (gbcpu-b cpu) (gbcpu-c cpu)))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x0c) (make-instruction :opcode #x0c :bytes 1 :cycles '(1 1) :asm '(:inc "C")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-c cpu) (incr-reg cpu #'gbcpu-c))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x0d) (make-instruction :opcode #x0d :bytes 1 :cycles '(1 1) :asm '(:dec "C")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-c cpu) (decr-reg cpu #'gbcpu-c))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x0e) (make-instruction :opcode #x0e :bytes 2 :cycles '(2 2) :asm '(:ld "C,u8")
                                        :fun (lambda (cpu instr)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-c cpu) b)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x0f) (make-instruction :opcode #x0f :bytes 1 :cycles '(1 1) :asm '(:rrca)
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-a cpu ) (rot-right-c-reg cpu (gbcpu-a cpu)))
                                               (incr-cpu-counters cpu instr))))

;;(setf (aref ops #x10) (make-instruction :opcode #x10 :bytes 1 :cycles '(1 1) :asm '(:stop)
;;                                        :fun (lambda (cpu instr) (incr-cpu-counters cpu instr))))
(setf (aref ops #x11) (make-instruction :opcode #x11 :bytes 3 :cycles '(3 3) :asm '(:ld "DE,u16")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (set-reg-pair-de-to-val cpu addr)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x12) (make-instruction :opcode #x12 :bytes 1 :cycles '(2 2) :asm '(:ld "(DE),A")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-d cpu) (gbcpu-e cpu))))
                                                  (write-memory-at-addr addr (gbcpu-a cpu))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x13) (make-instruction :opcode #x13 :bytes 1 :cycles '(2 2) :asm '(:inc "DE")
                                        :fun (lambda (cpu instr)
                                                  (set-reg-pair-de-to-val cpu (incr-reg-pair (gbcpu-d cpu) (gbcpu-e cpu)))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x14) (make-instruction :opcode #x14 :bytes 1 :cycles '(1 1) :asm '(:inc "D")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-d cpu) (incr-reg cpu #'gbcpu-d))
                                                  (incr-cpu-counters cpu instr))))

(setf (aref ops #x15) (make-instruction :opcode #x15 :bytes 1 :cycles '(1 1) :asm '(:dec "D")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-d cpu) (decr-reg cpu #'gbcpu-d))
                                                  (incr-cpu-counters cpu instr))))

(setf (aref ops #x16) (make-instruction :opcode #x16 :bytes 2 :cycles '(2 2) :asm '(:ld "D,u8")
                                        :fun (lambda (cpu instr)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-d cpu) b)
                                                  (incr-cpu-counters cpu instr)))))

(setf (aref ops #x17) (make-instruction :opcode #x17 :bytes 1 :cycles '(1 1) :asm '(:rla)
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-a cpu ) (rot-left-reg cpu (gbcpu-a cpu)))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x18) (make-instruction :opcode #x18 :bytes 2 :cycles '(3 0) :asm '(:jr "i8")
                                        :fun (lambda (cpu instr)
                                                (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                       (addr (get-new-addr-from-relative (+ (gbcpu-pc cpu) 2) b)))
                                                    (incr-cpu-counters cpu instr)
                                                    (do-jump cpu addr)))))
(setf (aref ops #x19) (make-instruction :opcode #x19 :bytes 1 :cycles '(2 2) :asm '(:add "HL,DE")
                                        :fun (lambda (cpu instr)
                                                (set-reg-pair-hl-to-val
                                                  cpu (add16 cpu
                                                             (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))
                                                             (get-address-from-reg-pair (gbcpu-d cpu) (gbcpu-e cpu))))
                                                (incr-cpu-counters cpu instr))))
(setf (aref ops #x1a)
      (make-instruction
        :opcode #x1a :bytes 1 :cycles '(2 2) :asm '(:ld "A,(DE)")
        :fun (lambda (cpu instr)
                (let* ((addr (get-address-from-reg-pair (gbcpu-d cpu) (gbcpu-e cpu)))
                      (val (aref memory addr)))
                  (setf (gbcpu-a cpu) val)
                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x1b) (make-instruction :opcode #x1b :bytes 1 :cycles '(2 2) :asm '(:inc "DE")
                                        :fun (lambda (cpu instr)
                                                  (set-reg-pair-de-to-val cpu (decr-reg-pair (gbcpu-d cpu) (gbcpu-e cpu)))
                                                  (incr-cpu-counters cpu instr))))

(setf (aref ops #x1c) (make-instruction :opcode #x1c :bytes 1 :cycles '(1 1) :asm '(:inc "E")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-e cpu) (incr-reg cpu #'gbcpu-e))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x1d) (make-instruction :opcode #x1d :bytes 1 :cycles '(1 1) :asm '(:dec "E")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-e cpu) (decr-reg cpu #'gbcpu-e))
                                                  (incr-cpu-counters cpu instr))))

(setf (aref ops #x1e) (make-instruction :opcode #x1e :bytes 2 :cycles '(2 2) :asm '(:ld "E,u8")
                                        :fun (lambda (cpu instr)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-e cpu) b)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x1f) (make-instruction :opcode #x1f :bytes 1 :cycles '(1 1) :asm '(:rra)
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-a cpu ) (rot-right-reg cpu (gbcpu-a cpu)))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x20) (make-instruction :opcode #x20 :bytes 2 :cycles '(2 1) :asm '(:jr "NZ,i8")
                                        :fun (lambda (cpu instr)
                                                (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                       (addr (get-new-addr-from-relative (+ (gbcpu-pc cpu) 2) b)))
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-z (gbcpu-flags cpu)) #x00)
                                                    (progn (incr-branched-clocks cpu instr)
                                                    (do-jump cpu addr)))))))
(setf (aref ops #x21) (make-instruction :opcode #x21 :bytes 3 :cycles '(3 3) :asm '(:ld "HL,u16")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (set-reg-pair-hl-to-val cpu addr)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x22) (make-instruction :opcode #x22 :bytes 1 :cycles '(2 2) :asm '(:ld "(HL+),A")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-a cpu))
                                                  (set-reg-pair-hl-to-val cpu (incr-reg-pair (gbcpu-h cpu) (gbcpu-l cpu)))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x23) (make-instruction :opcode #x23 :bytes 1 :cycles '(2 2) :asm '(:inc "HL")
                                        :fun (lambda (cpu instr)
                                                  (set-reg-pair-hl-to-val cpu (incr-reg-pair (gbcpu-h cpu) (gbcpu-l cpu)))
                                                  (incr-cpu-counters cpu instr))))

(setf (aref ops #x24) (make-instruction :opcode #x24 :bytes 1 :cycles '(1 1) :asm '(:inc "H")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-h cpu) (incr-reg cpu #'gbcpu-h))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x25) (make-instruction :opcode #x25 :bytes 1 :cycles '(1 1) :asm '(:dec "H")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-h cpu) (decr-reg cpu #'gbcpu-h))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x26) (make-instruction :opcode #x26 :bytes 2 :cycles '(2 2) :asm '(:ld "H,u8")
                                        :fun (lambda (cpu instr)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-h cpu) b)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x27) (make-instruction
                        :opcode #x27 :bytes 1 :cycles '(1 1) :asm '(:daa)
                        :fun (lambda (cpu instr)
                               (let* ((a (gbcpu-a cpu))
                                     (cor-lsb (if (or
                                                    (= (gbflags-h (gbcpu-flags cpu)) #x01)
                                                    (> (logand a #x0f) #x09))
                                                #x06
                                                #x00))
                                     (correction (logior cor-lsb (if (or
                                                    (= (gbflags-c (gbcpu-flags cpu)) #x01)
                                                    (> a #x99))
                                                #x60
                                                #x00)))
                                     (res (if (= (gbflags-n (gbcpu-flags cpu)) #x01)
                                            (sub cpu a correction)
                                            (add cpu a correction))))
                                  (setf (gbcpu-a cpu) (logand res #xff)
                                        (gbflags-h (gbcpu-flags cpu)) #x00
                                        (gbflags-c (gbcpu-flags cpu)) (if (> res #x99) #x01 #x00))
                                  (incr-cpu-counters cpu instr)))))

(setf (aref ops #x28) (make-instruction :opcode #x28 :bytes 2 :cycles '(2 1) :asm '(:jr "Z,i8")
                                        :fun (lambda (cpu instr)
                                                (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                       (addr (get-new-addr-from-relative (+ (gbcpu-pc cpu) 2) b)))
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-z (gbcpu-flags cpu)) #x01)
                                                    (progn (incr-branched-clocks cpu instr)
                                                    (do-jump cpu addr)))))))
(setf (aref ops #x29) (make-instruction :opcode #x29 :bytes 1 :cycles '(2 2) :asm '(:add "HL,HL")
                                        :fun (lambda (cpu instr)
                                                (set-reg-pair-hl-to-val
                                                  cpu (add16 cpu
                                                             (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))
                                                             (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                (incr-cpu-counters cpu instr))))
(setf (aref ops #x2a) (make-instruction :opcode #x2a :bytes 1 :cycles '(2 2) :asm '(:ld "A,(HL+)")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (get-byte-from-hl-address cpu))
                                                  (set-reg-pair-hl-to-val cpu (incr-reg-pair (gbcpu-h cpu) (gbcpu-l cpu)))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x2b) (make-instruction :opcode #x2b :bytes 1 :cycles '(2 2) :asm '(:inc "HL")
                                        :fun (lambda (cpu instr)
                                                  (set-reg-pair-hl-to-val cpu (decr-reg-pair (gbcpu-h cpu) (gbcpu-l cpu)))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x2c) (make-instruction :opcode #x2c :bytes 1 :cycles '(1 1) :asm '(:inc "L")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-l cpu) (incr-reg cpu #'gbcpu-l))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x2d) (make-instruction :opcode #x2d :bytes 1 :cycles '(1 1) :asm '(:dec "L")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-l cpu) (decr-reg cpu #'gbcpu-l))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x2e) (make-instruction :opcode #x2e :bytes 2 :cycles '(2 2) :asm '(:ld "L,u8")
                                        :fun (lambda (cpu instr)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-l cpu) b)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x2f) (make-instruction :opcode #x2f :bytes 1 :cycles '(1 1) :asm '(:cpl)
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (logxor (gbcpu-a cpu) #xff)
                                                        (gbflags-n (gbcpu-flags cpu)) #x01
                                                        (gbflags-h (gbcpu-flags cpu)) #x01)
                                                  (incr-cpu-counters cpu instr))))

(setf (aref ops #x30) (make-instruction :opcode #x30 :bytes 2 :cycles '(2 1) :asm '(:jr "NC,i8")
                                        :fun (lambda (cpu instr)
                                                (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                       (addr (get-new-addr-from-relative (+ (gbcpu-pc cpu) 2) b)))
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-c (gbcpu-flags cpu)) #x00)
                                                    (progn (incr-branched-clocks cpu instr)
                                                    (do-jump cpu addr)))))))
(setf (aref ops #x31) (make-instruction :opcode #x31 :bytes 3 :cycles '(3 0) :asm '(:ld "SP,u16")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-sp cpu) addr)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x32) (make-instruction :opcode #x32 :bytes 1 :cycles '(2 2) :asm '(:ld "(HL-),A")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-a cpu))
                                                  (set-reg-pair-hl-to-val cpu (decr-reg-pair (gbcpu-h cpu) (gbcpu-l cpu)))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x33) (make-instruction :opcode #x33 :bytes 1 :cycles '(2 2) :asm '(:inc "SP")
                                        :fun (lambda (cpu instr)
                                               (let ((res (logand (+ (gbcpu-sp cpu) 1) #xffff)))
                                                  (setf (gbcpu-sp cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x35) (make-instruction :opcode #x35 :bytes 1 :cycles '(3 3) :asm '(:dec "(HL)")
                                        :fun (lambda (cpu instr)
                                                  (setf
                                                    (aref memory (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu)))
                                                    (decr-reg cpu #'get-byte-from-hl-address))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x36) (make-instruction :opcode #x36 :bytes 2 :cycles '(3 3) :asm '(:ld "(HL),u8")
                                        :fun (lambda (cpu instr)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                      (addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr b)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x37) (make-instruction :opcode #x37 :bytes 1 :cycles '(1 1) :asm '(:scf)
                                        :fun (lambda (cpu instr)
                                                  (setf (gbflags-n (gbcpu-flags cpu)) #x00
                                                        (gbflags-h (gbcpu-flags cpu)) #x00
                                                        (gbflags-c (gbcpu-flags cpu)) #x01)
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x38) (make-instruction :opcode #x38 :bytes 2 :cycles '(2 1) :asm '(:jr "C,i8")
                                        :fun (lambda (cpu instr)
                                                (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                       (addr (get-new-addr-from-relative (+ (gbcpu-pc cpu) 2) b)))
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-c (gbcpu-flags cpu)) #x01)
                                                    (progn (incr-branched-clocks cpu instr)
                                                    (do-jump cpu addr)))))))
(setf (aref ops #x39) (make-instruction :opcode #x39 :bytes 1 :cycles '(2 2) :asm '(:add "HL,SP")
                                        :fun (lambda (cpu instr)
                                                (set-reg-pair-hl-to-val
                                                  cpu (add16 cpu
                                                             (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))
                                                             (gbcpu-sp cpu)))
                                                (incr-cpu-counters cpu instr))))
(setf (aref ops #x3b) (make-instruction :opcode #x3b :bytes 1 :cycles '(2 2) :asm '(:dec "SP")
                                        :fun (lambda (cpu instr)
                                               (let ((res (logand (- (gbcpu-sp cpu) 1) #xffff)))
                                                  (setf (gbcpu-sp cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x3c) (make-instruction :opcode #x3c :bytes 1 :cycles '(1 1) :asm '(:inc "A")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (incr-reg cpu #'gbcpu-a))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x3d) (make-instruction :opcode #x3d :bytes 1 :cycles '(1 1) :asm '(:dec "A")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (decr-reg cpu #'gbcpu-a))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x3e) (make-instruction :opcode #x3e :bytes 2 :cycles '(2 2) :asm '(:ld "A,u8")
                                        :fun (lambda (cpu instr)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-a cpu) b)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x3f) (make-instruction :opcode #x3f :bytes 1 :cycles '(1 1) :asm '(:ccf)
                                        :fun (lambda (cpu instr)
                                                  (setf (gbflags-n (gbcpu-flags cpu)) #x00
                                                        (gbflags-h (gbcpu-flags cpu)) #x00
                                                        (gbflags-c (gbcpu-flags cpu)) (logxor (gbflags-c (gbcpu-flags cpu)) #x01))
                                                  (incr-cpu-counters cpu instr))))

;; Load Block

;; Load Into B
(setf (aref ops #x40) (make-instruction :opcode #x40 :bytes 1 :cycles '(1 1) :asm '(:ld "B,B")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-b cpu) (gbcpu-b cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x41) (make-instruction :opcode #x41 :bytes 1 :cycles '(1 1) :asm '(:ld "B,C")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-b cpu) (gbcpu-c cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x42) (make-instruction :opcode #x42 :bytes 1 :cycles '(1 1) :asm '(:ld "B,D")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-b cpu) (gbcpu-d cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x43) (make-instruction :opcode #x43 :bytes 1 :cycles '(1 1) :asm '(:ld "B,E")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-b cpu) (gbcpu-e cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x44) (make-instruction :opcode #x44 :bytes 1 :cycles '(1 1) :asm '(:ld "B,H")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-b cpu) (gbcpu-h cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x45) (make-instruction :opcode #x45 :bytes 1 :cycles '(1 1) :asm '(:ld "B,L")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-b cpu) (gbcpu-l cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x46) (make-instruction :opcode #x46 :bytes 1 :cycles '(2 2) :asm '(:ld "B,(HL)")
                                        :fun (lambda (cpu instr)
                                                 (setf (gbcpu-b cpu) (get-byte-from-hl-address cpu))
                                                 (incr-cpu-counters cpu instr))))
(setf (aref ops #x47) (make-instruction :opcode #x47 :bytes 1 :cycles '(1 1) :asm '(:ld "B,A")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-b cpu) (gbcpu-a cpu))
                                               (incr-cpu-counters cpu instr))))

;; Load Into C
(setf (aref ops #x48) (make-instruction :opcode #x48 :bytes 1 :cycles '(1 1) :asm '(:ld "C,B")
                                        :fun (lambda (cpu instr)
                                                 (setf (gbcpu-c cpu) (gbcpu-b cpu))
                                                 (incr-cpu-counters cpu instr))))
(setf (aref ops #x49) (make-instruction :opcode #x49 :bytes 1 :cycles '(1 1) :asm '(:ld "C,C")
                                        :fun (lambda (cpu instr)
                                                 (setf (gbcpu-c cpu) (gbcpu-c cpu))
                                                 (incr-cpu-counters cpu instr))))
(setf (aref ops #x4a) (make-instruction :opcode #x4a :bytes 1 :cycles '(1 1) :asm '(:ld "C,D")
                                        :fun (lambda (cpu instr)
                                                 (setf (gbcpu-c cpu) (gbcpu-d cpu))
                                                 (incr-cpu-counters cpu instr))))
(setf (aref ops #x4b) (make-instruction :opcode #x4b :bytes 1 :cycles '(1 1) :asm '(:ld "C,E")
                                        :fun (lambda (cpu instr)
                                                 (setf (gbcpu-c cpu) (gbcpu-e cpu))
                                                 (incr-cpu-counters cpu instr))))
(setf (aref ops #x4c) (make-instruction :opcode #x4c :bytes 1 :cycles '(1 1) :asm '(:ld "C,H")
                                        :fun (lambda (cpu instr)
                                                 (setf (gbcpu-c cpu) (gbcpu-h cpu))
                                                 (incr-cpu-counters cpu instr))))
(setf (aref ops #x4d) (make-instruction :opcode #x4d :bytes 1 :cycles '(1 1) :asm '(:ld "C,L")
                                        :fun (lambda (cpu instr)
                                                 (setf (gbcpu-c cpu) (gbcpu-l cpu))
                                                 (incr-cpu-counters cpu instr))))
(setf (aref ops #x4e) (make-instruction :opcode #x4e :bytes 1 :cycles '(2 2) :asm '(:ld "C,(HL)")
                                        :fun (lambda (cpu instr)
                                                 (setf (gbcpu-c cpu) (get-byte-from-hl-address cpu))
                                                 (incr-cpu-counters cpu instr))))
(setf (aref ops #x4f) (make-instruction :opcode #x4f :bytes 1 :cycles '(1 1) :asm '(:ld "C,A")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-c cpu) (gbcpu-a cpu))
                                                  (incr-cpu-counters cpu instr))))

;; Load Into D
(setf (aref ops #x50) (make-instruction :opcode #x50 :bytes 1 :cycles '(1 1) :asm '(:ld "D,B")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-d cpu) (gbcpu-b cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x51) (make-instruction :opcode #x51 :bytes 1 :cycles '(1 1) :asm '(:ld "D,C")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-d cpu) (gbcpu-c cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x52) (make-instruction :opcode #x52 :bytes 1 :cycles '(1 1) :asm '(:ld "D,D")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-d cpu) (gbcpu-d cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x53) (make-instruction :opcode #x53 :bytes 1 :cycles '(1 1) :asm '(:ld "D,E")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-d cpu) (gbcpu-e cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x54) (make-instruction :opcode #x54 :bytes 1 :cycles '(1 1) :asm '(:ld "D,H")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-d cpu) (gbcpu-h cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x55) (make-instruction :opcode #x55 :bytes 1 :cycles '(1 1) :asm '(:ld "D,L")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-d cpu) (gbcpu-l cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x56) (make-instruction :opcode #x56 :bytes 1 :cycles '(2 2) :asm '(:ld "D,(HL)")
                                        :fun (lambda (cpu instr)
                                                 (setf (gbcpu-d cpu) (get-byte-from-hl-address cpu))
                                                 (incr-cpu-counters cpu instr))))
(setf (aref ops #x57) (make-instruction :opcode #x57 :bytes 1 :cycles '(1 1) :asm '(:ld "D,A")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-d cpu) (gbcpu-a cpu))
                                               (incr-cpu-counters cpu instr))))

;; Load Into E
(setf (aref ops #x58) (make-instruction :opcode #x58 :bytes 1 :cycles '(1 1) :asm '(:ld "E,B")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-e cpu) (gbcpu-b cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x59) (make-instruction :opcode #x59 :bytes 1 :cycles '(1 1) :asm '(:ld "E,C")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-e cpu) (gbcpu-c cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x5a) (make-instruction :opcode #x5a :bytes 1 :cycles '(1 1) :asm '(:ld "E,D")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-e cpu) (gbcpu-d cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x5b) (make-instruction :opcode #x5b :bytes 1 :cycles '(1 1) :asm '(:ld "E,E")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-e cpu) (gbcpu-e cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x5c) (make-instruction :opcode #x5c :bytes 1 :cycles '(1 1) :asm '(:ld "E,H")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-e cpu) (gbcpu-h cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x5d) (make-instruction :opcode #x5d :bytes 1 :cycles '(1 1) :asm '(:ld "E,L")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-e cpu) (gbcpu-l cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x5e) (make-instruction :opcode #x5e :bytes 1 :cycles '(2 2) :asm '(:ld "E,(HL)")
                                        :fun (lambda (cpu instr)
                                                 (setf (gbcpu-e cpu) (get-byte-from-hl-address cpu))
                                                 (incr-cpu-counters cpu instr))))
(setf (aref ops #x5f) (make-instruction :opcode #x5f :bytes 1 :cycles '(1 1) :asm '(:ld "E,A")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-e cpu) (gbcpu-a cpu))
                                                  (incr-cpu-counters cpu instr))))

;; Load Into H
(setf (aref ops #x60) (make-instruction :opcode #x60 :bytes 1 :cycles '(1 1) :asm '(:ld "H,B")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-h cpu) (gbcpu-b cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x61) (make-instruction :opcode #x61 :bytes 1 :cycles '(1 1) :asm '(:ld "H,C")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-h cpu) (gbcpu-c cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x62) (make-instruction :opcode #x62 :bytes 1 :cycles '(1 1) :asm '(:ld "H,D")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-h cpu) (gbcpu-d cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x63) (make-instruction :opcode #x63 :bytes 1 :cycles '(1 1) :asm '(:ld "H,E")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-h cpu) (gbcpu-e cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x64) (make-instruction :opcode #x64 :bytes 1 :cycles '(1 1) :asm '(:ld "H,H")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-h cpu) (gbcpu-h cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x65) (make-instruction :opcode #x65 :bytes 1 :cycles '(1 1) :asm '(:ld "H,L")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-h cpu) (gbcpu-l cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x66) (make-instruction :opcode #x66 :bytes 1 :cycles '(2 2) :asm '(:ld "H,(HL)")
                                        :fun (lambda (cpu instr)
                                                 (setf (gbcpu-h cpu) (get-byte-from-hl-address cpu))
                                                 (incr-cpu-counters cpu instr))))
(setf (aref ops #x67) (make-instruction :opcode #x67 :bytes 1 :cycles '(1 1) :asm '(:ld "H,A")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-h cpu) (gbcpu-a cpu))
                                               (incr-cpu-counters cpu instr))))

;; Load Into L
(setf (aref ops #x68) (make-instruction :opcode #x68 :bytes 1 :cycles '(1 1) :asm '(:ld "L,B")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-l cpu) (gbcpu-b cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x69) (make-instruction :opcode #x69 :bytes 1 :cycles '(1 1) :asm '(:ld "L,C")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-l cpu) (gbcpu-c cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x6a) (make-instruction :opcode #x6a :bytes 1 :cycles '(1 1) :asm '(:ld "L,D")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-l cpu) (gbcpu-d cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x6b) (make-instruction :opcode #x6b :bytes 1 :cycles '(1 1) :asm '(:ld "L,E")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-l cpu) (gbcpu-e cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x6c) (make-instruction :opcode #x6c :bytes 1 :cycles '(1 1) :asm '(:ld "L,H")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-l cpu) (gbcpu-h cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x6d) (make-instruction :opcode #x6d :bytes 1 :cycles '(1 1) :asm '(:ld "L,L")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-l cpu) (gbcpu-l cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x6e) (make-instruction :opcode #x6e :bytes 1 :cycles '(2 2) :asm '(:ld "L,(HL)")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-l cpu) (get-byte-from-hl-address cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x6f) (make-instruction :opcode #x6f :bytes 1 :cycles '(1 1) :asm '(:ld "L,A")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-l cpu) (gbcpu-a cpu))
                                               (incr-cpu-counters cpu instr))))

;; Load Into (HL)
(setf (aref ops #x70) (make-instruction :opcode #x70 :bytes 1 :cycles '(2 2) :asm '(:ld "(HL),B")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-b cpu))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x71) (make-instruction :opcode #x71 :bytes 1 :cycles '(2 2) :asm '(:ld "(HL),C")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-c cpu))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x72) (make-instruction :opcode #x72 :bytes 1 :cycles '(2 2) :asm '(:ld "(HL),D")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-d cpu))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x73) (make-instruction :opcode #x73 :bytes 1 :cycles '(2 2) :asm '(:ld "(HL),E")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-e cpu))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x74) (make-instruction :opcode #x74 :bytes 1 :cycles '(2 2) :asm '(:ld "(HL),H")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-h cpu))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x75) (make-instruction :opcode #x75 :bytes 1 :cycles '(2 2) :asm '(:ld "(HL),L")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-l cpu))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #x76) (make-instruction :opcode #x76 :bytes 1 :cycles '(1 1) :asm '(:halt)
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-halted cpu) #x01)
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x77) (make-instruction :opcode #x77 :bytes 1 :cycles '(2 2) :asm '(:ld "(HL),A")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))
                                                  (write-memory-at-addr addr (gbcpu-a cpu))
                                                  (incr-cpu-counters cpu instr)))))

;; Load Into A
(setf (aref ops #x78) (make-instruction :opcode #x78 :bytes 1 :cycles '(1 1) :asm '(:ld "A,B")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (gbcpu-b cpu))
                                                  (incr-cpu-counters cpu instr))))

(setf (aref ops #x79) (make-instruction :opcode #x79 :bytes 1 :cycles '(1 1) :asm '(:ld "A,C")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (gbcpu-c cpu))
                                                  (incr-cpu-counters cpu instr))))

(setf (aref ops #x7a) (make-instruction :opcode #x7a :bytes 1 :cycles '(1 1) :asm '(:ld "A,D")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (gbcpu-d cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x7b) (make-instruction :opcode #x7b :bytes 1 :cycles '(1 1) :asm '(:ld "A,E")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (gbcpu-e cpu))
                                                  (incr-cpu-counters cpu instr))))

(setf (aref ops #x7c) (make-instruction :opcode #x7c :bytes 1 :cycles '(1 1) :asm '(:ld "A,H")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (gbcpu-h cpu))
                                                  (incr-cpu-counters cpu instr))))

(setf (aref ops #x7d) (make-instruction :opcode #x7d :bytes 1 :cycles '(1 1) :asm '(:ld "A,L")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (gbcpu-l cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x7e) (make-instruction :opcode #x7e :bytes 1 :cycles '(2 2) :asm '(:ld "A,(HL)")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-a cpu) (get-byte-from-hl-address cpu))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #x7f) (make-instruction :opcode #x7f :bytes 1 :cycles '(1 1) :asm '(:ld "A,A")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (gbcpu-a cpu))
                                                  (incr-cpu-counters cpu instr))))

;; Arithmentic
;; ADDs
(setf (aref ops #x80) (make-instruction :opcode #x80 :bytes 1 :cycles '(1 1) :asm '(:add "A,B")
                                        :fun (lambda (cpu instr)
                                               (let ((res (add cpu (gbcpu-a cpu) (gbcpu-b cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x81) (make-instruction :opcode #x81 :bytes 1 :cycles '(1 1) :asm '(:add "A,C")
                                        :fun (lambda (cpu instr)
                                               (let ((res (add cpu (gbcpu-a cpu) (gbcpu-c cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x82) (make-instruction :opcode #x82 :bytes 1 :cycles '(1 1) :asm '(:add "A,D")
                                        :fun (lambda (cpu instr)
                                               (let ((res (add cpu (gbcpu-a cpu) (gbcpu-d cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x83) (make-instruction :opcode #x83 :bytes 1 :cycles '(1 1) :asm '(:add "A,E")
                                        :fun (lambda (cpu instr)
                                               (let ((res (add cpu (gbcpu-a cpu) (gbcpu-e cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x84) (make-instruction :opcode #x84 :bytes 1 :cycles '(1 1) :asm '(:add "A,H")
                                        :fun (lambda (cpu instr)
                                               (let ((res (add cpu (gbcpu-a cpu) (gbcpu-h cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x85) (make-instruction :opcode #x85 :bytes 1 :cycles '(1 1) :asm '(:add "A,L")
                                        :fun (lambda (cpu instr)
                                               (let ((res (add cpu (gbcpu-a cpu) (gbcpu-l cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x86) (make-instruction :opcode #x86 :bytes 1 :cycles '(2 2) :asm '(:add "A,(HL)")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (add cpu (gbcpu-a cpu) (get-byte-from-hl-address cpu)))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x87) (make-instruction :opcode #x87 :bytes 1 :cycles '(1 1) :asm '(:add "A,A")
                                        :fun (lambda (cpu instr)
                                               (let ((res (add cpu (gbcpu-a cpu) (gbcpu-a cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))

;; ADCs
(setf (aref ops #x88) (make-instruction :opcode #x88 :bytes 1 :cycles '(1 1) :asm '(:adc "A,B")
                                        :fun (lambda (cpu instr)
                                               (let ((res (adc cpu (gbcpu-a cpu) (gbcpu-b cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x89) (make-instruction :opcode #x89 :bytes 1 :cycles '(1 1) :asm '(:adc "A,C")
                                        :fun (lambda (cpu instr)
                                               (let ((res (adc cpu (gbcpu-a cpu) (gbcpu-c cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x8a) (make-instruction :opcode #x8a :bytes 1 :cycles '(1 1) :asm '(:adc "A,D")
                                        :fun (lambda (cpu instr)
                                               (let ((res (adc cpu (gbcpu-a cpu) (gbcpu-d cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x8b) (make-instruction :opcode #x8b :bytes 1 :cycles '(1 1) :asm '(:adc "A,E")
                                        :fun (lambda (cpu instr)
                                               (let ((res (adc cpu (gbcpu-a cpu) (gbcpu-e cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x8c) (make-instruction :opcode #x8c :bytes 1 :cycles '(1 1) :asm '(:adc "A,H")
                                        :fun (lambda (cpu instr)
                                               (let ((res (adc cpu (gbcpu-a cpu) (gbcpu-h cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x8d) (make-instruction :opcode #x8d :bytes 1 :cycles '(1 1) :asm '(:adc "A,L")
                                        :fun (lambda (cpu instr)
                                               (let ((res (adc cpu (gbcpu-a cpu) (gbcpu-l cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x8e) (make-instruction :opcode #x8e :bytes 1 :cycles '(2 2) :asm '(:adc "A,(HL)")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (adc cpu (gbcpu-a cpu) (get-byte-from-hl-address cpu)))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x8f) (make-instruction :opcode #x8f :bytes 1 :cycles '(1 1) :asm '(:adc "A,A")
                                        :fun (lambda (cpu instr)
                                               (let ((res (adc cpu (gbcpu-a cpu) (gbcpu-a cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))

;; SUBs
(setf (aref ops #x90) (make-instruction :opcode #x90 :bytes 1 :cycles '(1 1) :asm '(:sub "A,B")
                                        :fun (lambda (cpu instr)
                                               (let ((res (sub cpu (gbcpu-a cpu) (gbcpu-b cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x91) (make-instruction :opcode #x91 :bytes 1 :cycles '(1 1) :asm '(:sub "A,C")
                                        :fun (lambda (cpu instr)
                                               (let ((res (sub cpu (gbcpu-a cpu) (gbcpu-c cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x92) (make-instruction :opcode #x92 :bytes 1 :cycles '(1 1) :asm '(:sub "A,D")
                                        :fun (lambda (cpu instr)
                                               (let ((res (sub cpu (gbcpu-a cpu) (gbcpu-d cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x93) (make-instruction :opcode #x93 :bytes 1 :cycles '(1 1) :asm '(:sub "A,E")
                                        :fun (lambda (cpu instr)
                                               (let ((res (sub cpu (gbcpu-a cpu) (gbcpu-e cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x94) (make-instruction :opcode #x94 :bytes 1 :cycles '(1 1) :asm '(:sub "A,H")
                                        :fun (lambda (cpu instr)
                                               (let ((res (sub cpu (gbcpu-a cpu) (gbcpu-h cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x95) (make-instruction :opcode #x95 :bytes 1 :cycles '(1 1) :asm '(:sub "A,L")
                                        :fun (lambda (cpu instr)
                                               (let ((res (sub cpu (gbcpu-a cpu) (gbcpu-l cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x96) (make-instruction :opcode #x96 :bytes 1 :cycles '(2 2) :asm '(:sub "A,(HL)")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (sub cpu (gbcpu-a cpu) (get-byte-from-hl-address cpu)))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x97) (make-instruction :opcode #x97 :bytes 1 :cycles '(1 1) :asm '(:sub "A,A")
                                        :fun (lambda (cpu instr)
                                               (let ((res (sub cpu (gbcpu-a cpu) (gbcpu-a cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))

;; SBCs
(setf (aref ops #x98) (make-instruction :opcode #x98 :bytes 1 :cycles '(1 1) :asm '(:sbc "A,B")
                                        :fun (lambda (cpu instr)
                                               (let ((res (sbc cpu (gbcpu-a cpu) (gbcpu-b cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x99) (make-instruction :opcode #x99 :bytes 1 :cycles '(1 1) :asm '(:sbc "A,C")
                                        :fun (lambda (cpu instr)
                                               (let ((res (sbc cpu (gbcpu-a cpu) (gbcpu-c cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x9a) (make-instruction :opcode #x9a :bytes 1 :cycles '(1 1) :asm '(:sbc "A,D")
                                        :fun (lambda (cpu instr)
                                               (let ((res (sbc cpu (gbcpu-a cpu) (gbcpu-d cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x9b) (make-instruction :opcode #x9b :bytes 1 :cycles '(1 1) :asm '(:sbc "A,E")
                                        :fun (lambda (cpu instr)
                                               (let ((res (sbc cpu (gbcpu-a cpu) (gbcpu-e cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x9c) (make-instruction :opcode #x9c :bytes 1 :cycles '(1 1) :asm '(:sbc "A,H")
                                        :fun (lambda (cpu instr)
                                               (let ((res (sbc cpu (gbcpu-a cpu) (gbcpu-h cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x9d) (make-instruction :opcode #x9d :bytes 1 :cycles '(1 1) :asm '(:sbc "A,L")
                                        :fun (lambda (cpu instr)
                                               (let ((res (sbc cpu (gbcpu-a cpu) (gbcpu-l cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))
(setf (aref ops #x9e) (make-instruction :opcode #x9e :bytes 1 :cycles '(2 2) :asm '(:sbc "A,(HL)")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (sbc cpu (gbcpu-a cpu) (get-byte-from-hl-address cpu)))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #x9f) (make-instruction :opcode #x9f :bytes 1 :cycles '(1 1) :asm '(:sbc "A,A")
                                        :fun (lambda (cpu instr)
                                               (let ((res (sbc cpu (gbcpu-a cpu) (gbcpu-a cpu))))
                                                 (setf (gbcpu-a cpu) res)
                                                 (incr-cpu-counters cpu instr)))))

;; ANDs
(setf (aref ops #xa0) (make-instruction :opcode #xa0 :bytes 1 :cycles '(1 1) :asm '(:and "A,B")
                                        :fun (lambda (cpu instr)
                                               (let ((res (and-op cpu (gbcpu-a cpu) (gbcpu-b cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xa1) (make-instruction :opcode #xa1 :bytes 1 :cycles '(1 1) :asm '(:and "A,C")
                                        :fun (lambda (cpu instr)
                                               (let ((res (and-op cpu (gbcpu-a cpu) (gbcpu-c cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xa2) (make-instruction :opcode #xa2 :bytes 1 :cycles '(1 1) :asm '(:and "A,D")
                                        :fun (lambda (cpu instr)
                                               (let ((res (and-op cpu (gbcpu-a cpu) (gbcpu-d cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xa3) (make-instruction :opcode #xa3 :bytes 1 :cycles '(1 1) :asm '(:and "A,E")
                                        :fun (lambda (cpu instr)
                                               (let ((res (and-op cpu (gbcpu-a cpu) (gbcpu-e cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xa4) (make-instruction :opcode #xa4 :bytes 1 :cycles '(1 1) :asm '(:and "A,H")
                                        :fun (lambda (cpu instr)
                                               (let ((res (and-op cpu (gbcpu-a cpu) (gbcpu-h cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xa5) (make-instruction :opcode #xa5 :bytes 1 :cycles '(1 1) :asm '(:and "A,L")
                                        :fun (lambda (cpu instr)
                                               (let ((res (and-op cpu (gbcpu-a cpu) (gbcpu-l cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xa6) (make-instruction :opcode #xa6 :bytes 1 :cycles '(2 2) :asm '(:and "A,(HL)")
                                        :fun (lambda (cpu instr)
                                               (let ((res (and-op cpu (gbcpu-a cpu) (get-byte-from-hl-address cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xa7) (make-instruction :opcode #xa7 :bytes 1 :cycles '(1 1) :asm '(:and "A,A")
                                        :fun (lambda (cpu instr)
                                               (let ((res (and-op cpu (gbcpu-a cpu) (gbcpu-a cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))

;; XORs
(setf (aref ops #xa8) (make-instruction :opcode #xa8 :bytes 1 :cycles '(1 1) :asm '(:xor "A,B")
                                        :fun (lambda (cpu instr)
                                               (let ((res (xor cpu (gbcpu-a cpu) (gbcpu-b cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xa9) (make-instruction :opcode #xa9 :bytes 1 :cycles '(1 1) :asm '(:xor "A,C")
                                        :fun (lambda (cpu instr)
                                               (let ((res (xor cpu (gbcpu-a cpu) (gbcpu-c cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xaa) (make-instruction :opcode #xaa :bytes 1 :cycles '(1 1) :asm '(:xor "A,D")
                                        :fun (lambda (cpu instr)
                                               (let ((res (xor cpu (gbcpu-a cpu) (gbcpu-d cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xab) (make-instruction :opcode #xab :bytes 1 :cycles '(1 1) :asm '(:xor "A,E")
                                        :fun (lambda (cpu instr)
                                               (let ((res (xor cpu (gbcpu-a cpu) (gbcpu-e cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xac) (make-instruction :opcode #xac :bytes 1 :cycles '(1 1) :asm '(:xor "A,H")
                                        :fun (lambda (cpu instr)
                                               (let ((res (xor cpu (gbcpu-a cpu) (gbcpu-h cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xad) (make-instruction :opcode #xad :bytes 1 :cycles '(1 1) :asm '(:xor "A,L")
                                        :fun (lambda (cpu instr)
                                               (let ((res (xor cpu (gbcpu-a cpu) (gbcpu-l cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xae) (make-instruction :opcode #xae :bytes 1 :cycles '(2 2) :asm '(:xor "A,(HL)")
                                        :fun (lambda (cpu instr)
                                               (let ((res (xor cpu (gbcpu-a cpu) (get-byte-from-hl-address cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xaf) (make-instruction :opcode #xaf :bytes 1 :cycles '(1 1) :asm '(:xor "A,A")
                                        :fun (lambda (cpu instr)
                                               (let ((res (xor cpu (gbcpu-a cpu) (gbcpu-a cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))


;; ORs
(setf (aref ops #xb0) (make-instruction :opcode #xb0 :bytes 1 :cycles '(1 1) :asm '(:or "A,B")
                                        :fun (lambda (cpu instr)
                                               (let ((res (or-op cpu (gbcpu-a cpu) (gbcpu-b cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xb1) (make-instruction :opcode #xb1 :bytes 1 :cycles '(1 1) :asm '(:or "A,C")
                                        :fun (lambda (cpu instr)
                                               (let ((res (or-op cpu (gbcpu-a cpu) (gbcpu-c cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xb2) (make-instruction :opcode #xb2 :bytes 1 :cycles '(1 1) :asm '(:or "A,D")
                                        :fun (lambda (cpu instr)
                                               (let ((res (or-op cpu (gbcpu-a cpu) (gbcpu-d cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xb3) (make-instruction :opcode #xb3 :bytes 1 :cycles '(1 1) :asm '(:or "A,E")
                                        :fun (lambda (cpu instr)
                                               (let ((res (or-op cpu (gbcpu-a cpu) (gbcpu-e cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xb4) (make-instruction :opcode #xb4 :bytes 1 :cycles '(1 1) :asm '(:or "A,H")
                                        :fun (lambda (cpu instr)
                                               (let ((res (or-op cpu (gbcpu-a cpu) (gbcpu-h cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xb5) (make-instruction :opcode #xb5 :bytes 1 :cycles '(1 1) :asm '(:or "A,L")
                                        :fun (lambda (cpu instr)
                                               (let ((res (or-op cpu (gbcpu-a cpu) (gbcpu-l cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xb6) (make-instruction :opcode #xb6 :bytes 1 :cycles '(2 2) :asm '(:or "A,(HL)")
                                        :fun (lambda (cpu instr)
                                                  (setf (gbcpu-a cpu) (or-op cpu (gbcpu-a cpu) (get-byte-from-hl-address cpu)))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xb7) (make-instruction :opcode #xb7 :bytes 1 :cycles '(1 1) :asm '(:or "A,A")
                                        :fun (lambda (cpu instr)
                                               (let ((res (or-op cpu (gbcpu-a cpu) (gbcpu-a cpu))))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))

;; CPs
(setf (aref ops #xb8) (make-instruction :opcode #xb8 :bytes 1 :cycles '(1 1) :asm '(:cp "A,B")
                                           :fun (lambda (cpu instr)
                                                  (cp-reg-with-val cpu (gbcpu-a cpu) (gbcpu-b cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xb9) (make-instruction :opcode #xb9 :bytes 1 :cycles '(1 1) :asm '(:cp "A,C")
                                           :fun (lambda (cpu instr)
                                                  (cp-reg-with-val cpu (gbcpu-a cpu) (gbcpu-c cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xba) (make-instruction :opcode #xba :bytes 1 :cycles '(1 1) :asm '(:cp "A,D")
                                           :fun (lambda (cpu instr)
                                                  (cp-reg-with-val cpu (gbcpu-a cpu) (gbcpu-d cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xbb) (make-instruction :opcode #xbb :bytes 1 :cycles '(1 1) :asm '(:cp "A,E")
                                           :fun (lambda (cpu instr)
                                                  (cp-reg-with-val cpu (gbcpu-a cpu) (gbcpu-e cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xbc) (make-instruction :opcode #xbc :bytes 1 :cycles '(1 1) :asm '(:cp "A,H")
                                           :fun (lambda (cpu instr)
                                                  (cp-reg-with-val cpu (gbcpu-a cpu) (gbcpu-h cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xbd) (make-instruction :opcode #xbd :bytes 1 :cycles '(1 1) :asm '(:cp "A,L")
                                           :fun (lambda (cpu instr)
                                                  (cp-reg-with-val cpu (gbcpu-a cpu) (gbcpu-l cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xbe) (make-instruction :opcode #xbe :bytes 1 :cycles '(2 2) :asm '(:cp "A,(HL)")
                                           :fun (lambda (cpu instr)
                                                  (cp-reg-with-val cpu (gbcpu-a cpu) (get-byte-from-hl-address cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xbf) (make-instruction :opcode #xbf :bytes 1 :cycles '(1 1) :asm '(:cp "A,A")
                                           :fun (lambda (cpu instr)
                                                  (cp-reg-with-val cpu (gbcpu-a cpu) (gbcpu-a cpu))
                                                  (incr-cpu-counters cpu instr))))

;; Misc jp call rst ret
(setf (aref ops #xc0) (make-instruction :opcode #xc0 :bytes 1 :cycles '(2 3) :asm '(:ret "NZ")
                                        :fun (lambda (cpu instr)
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-z (gbcpu-flags cpu)) #x00)
                                                    (progn (incr-branched-clocks cpu instr)
                                                    (do-ret cpu))))))
(setf (aref ops #xc1) (make-instruction :opcode #xc1 :bytes 1 :cycles '(3 3) :asm '(:pop "BC")
                                        :fun (lambda (cpu instr)
                                                  (set-reg-pair-bc-to-val cpu (pop-addr-from-stack cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xc2) (make-instruction :opcode #xc2 :bytes 3 :cycles '(3 1) :asm '(:jp "NZ,u16")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-z (gbcpu-flags cpu)) #x00)
                                                    (progn (incr-branched-clocks cpu instr)
                                                    (do-jump cpu addr)))))))
(setf (aref ops #xc3) (make-instruction :opcode #xc3 :bytes 3 :cycles '(4 0) :asm '(:jp "u16")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                    (do-jump cpu addr)))))
(setf (aref ops #xc4) (make-instruction :opcode #xc4 :bytes 3 :cycles '(3 3) :asm '(:call "NZ,u16")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-z (gbcpu-flags cpu)) #x00)
                                                    (progn (incr-branched-clocks cpu instr)
                                                    (do-call-at-addr cpu addr)))))))
(setf (aref ops #xc5) (make-instruction :opcode #xc5 :bytes 1 :cycles '(4 4) :asm '(:push "BC")
                                        :fun (lambda (cpu instr)
                                                  (push-reg-pair-on-stack cpu (gbcpu-b cpu) (gbcpu-c cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xc6) (make-instruction :opcode #xc6 :bytes 2 :cycles '(2 2) :asm '(:add "A,u8")
                                        :fun (lambda (cpu instr)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-a cpu) (add cpu (gbcpu-a cpu) b))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xc7) (make-instruction :opcode #xc7 :bytes 1 :cycles '(4 4) :asm '(:rst "00h")
                                        :fun (lambda (cpu instr)
                                                  (incr-cpu-counters cpu instr)
                                                    (do-rst cpu #x00))))
(setf (aref ops #xc8) (make-instruction :opcode #xc8 :bytes 1 :cycles '(2 3) :asm '(:ret "Z")
                                        :fun (lambda (cpu instr)
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-z (gbcpu-flags cpu)) #x01)
                                                    (progn (incr-branched-clocks cpu instr)
                                                    (do-ret cpu))))))
(setf (aref ops #xc9) (make-instruction :opcode #xc9 :bytes 1 :cycles '(4 0) :asm '(:ret)
                                        :fun (lambda (cpu instr) (do-ret cpu))))
(setf (aref ops #xca) (make-instruction :opcode #xca :bytes 3 :cycles '(3 1) :asm '(:jp "Z,u16")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-z (gbcpu-flags cpu)) #x01)
                                                    (progn (incr-branched-clocks cpu instr)
                                                    (do-jump cpu addr)))))))
(setf (aref ops #xcc) (make-instruction :opcode #xcc :bytes 3 :cycles '(3 6) :asm '(:call "Z,u16")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-z (gbcpu-flags cpu)) #x01)
                                                    (progn (incr-branched-clocks cpu instr)
                                                    (do-call-at-addr cpu addr)))))))
(setf (aref ops #xcd) (make-instruction :opcode #xcd :bytes 3 :cycles '(6 0) :asm '(:call "u16")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (incr-cpu-counters cpu instr)
                                                  (do-call-at-addr cpu addr)))))
(setf (aref ops #xce) (make-instruction :opcode #xce :bytes 2 :cycles '(2 2) :asm '(:adc "A,u8")
                                        :fun (lambda (cpu instr)
                                               (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                      (res (adc cpu (gbcpu-a cpu) b)))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xcf) (make-instruction :opcode #xcf :bytes 1 :cycles '(4 4) :asm '(:rst "08h")
                                        :fun (lambda (cpu instr)
                                                  (incr-cpu-counters cpu instr)
                                                    (do-rst cpu #x08))))

(setf (aref ops #xd0) (make-instruction :opcode #xd0 :bytes 1 :cycles '(2 3) :asm '(:ret "NC")
                                        :fun (lambda (cpu instr)
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-c (gbcpu-flags cpu)) #x00)
                                                    (progn (incr-branched-clocks cpu instr)
                                                    (do-ret cpu))))))
(setf (aref ops #xd1) (make-instruction :opcode #xd1 :bytes 1 :cycles '(3 3) :asm '(:pop "DE")
                                        :fun (lambda (cpu instr)
                                                  (set-reg-pair-de-to-val cpu (pop-addr-from-stack cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xd2) (make-instruction :opcode #xd2 :bytes 3 :cycles '(3 1) :asm '(:jp "NC,u16")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-c (gbcpu-flags cpu)) #x00)
                                                    (progn (incr-branched-clocks cpu instr)
                                                    (do-jump cpu addr)))))))
(setf (aref ops #xd4) (make-instruction :opcode #xd4 :bytes 3 :cycles '(3 3) :asm '(:call "NC,u16")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-c (gbcpu-flags cpu)) #x00)
                                                    (progn (incr-branched-clocks cpu instr)
                                                    (do-call-at-addr cpu addr)))))))
(setf (aref ops #xd5) (make-instruction :opcode #xd5 :bytes 1 :cycles '(4 4) :asm '(:push "DE")
                                        :fun (lambda (cpu instr)
                                                  (push-reg-pair-on-stack cpu (gbcpu-d cpu) (gbcpu-e cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xd6) (make-instruction :opcode #xd6 :bytes 2 :cycles '(2 2) :asm '(:sub "A,u8")
                                        :fun (lambda (cpu instr)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-a cpu) (sub cpu (gbcpu-a cpu) b))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xd7) (make-instruction :opcode #xd7 :bytes 1 :cycles '(4 4) :asm '(:rst "10h")
                                        :fun (lambda (cpu instr)
                                                  (incr-cpu-counters cpu instr)
                                                    (do-rst cpu #x10))))
(setf (aref ops #xd8) (make-instruction :opcode #xd8 :bytes 1 :cycles '(2 3) :asm '(:ret "C")
                                        :fun (lambda (cpu instr)
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-c (gbcpu-flags cpu)) #x01)
                                                    (progn (incr-branched-clocks cpu instr)
                                                    (do-ret cpu))))))
(setf (aref ops #xd9) (make-instruction :opcode #xd9 :bytes 1 :cycles '(4 0) :asm '(:reti)
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-int-ena cpu) #x01)
                                               (do-ret cpu))))
(setf (aref ops #xda) (make-instruction :opcode #xda :bytes 3 :cycles '(3 1) :asm '(:jp "C,u16")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-c (gbcpu-flags cpu)) #x01)
                                                    (progn (incr-branched-clocks cpu instr)
                                                    (do-jump cpu addr)))))))
(setf (aref ops #xdc) (make-instruction :opcode #xdc :bytes 3 :cycles '(3 3) :asm '(:call "C,u16")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (incr-cpu-counters cpu instr)
                                                  (if (= (gbflags-c (gbcpu-flags cpu)) #x01)
                                                    (progn (incr-branched-clocks cpu instr)
                                                           (do-call-at-addr cpu addr)))))))
(setf (aref ops #xde) (make-instruction :opcode #xde :bytes 2 :cycles '(2 2) :asm '(:sbc "A,u8")
                                        :fun (lambda (cpu instr)
                                               (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                      (res (sbc cpu (gbcpu-a cpu) b)))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xdf) (make-instruction :opcode #xdf :bytes 1 :cycles '(4 4) :asm '(:rst "18h")
                                        :fun (lambda (cpu instr)
                                                  (incr-cpu-counters cpu instr)
                                                    (do-rst cpu #x18))))

(setf (aref ops #xe0) (make-instruction :opcode #xe0 :bytes 2 :cycles '(3 3) :asm '(:ld "(FF00+u8),A")
                                        :fun (lambda (cpu instr)
                                                (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                         (addr (+ #xff00 b)))
                                                  (write-memory-at-addr addr (gbcpu-a cpu))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xe1) (make-instruction :opcode #xe1 :bytes 1 :cycles '(3 3) :asm '(:pop "HL")
                                        :fun (lambda (cpu instr)
                                                  (set-reg-pair-hl-to-val cpu (pop-addr-from-stack cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xe2) (make-instruction :opcode #xe2 :bytes 1 :cycles '(2 2) :asm '(:ld "(FF00+C),A")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (+ #xff00 (gbcpu-c cpu))))
                                                  (write-memory-at-addr addr (gbcpu-a cpu))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xe5) (make-instruction :opcode #xe5 :bytes 1 :cycles '(4 4) :asm '(:push "HL")
                                        :fun (lambda (cpu instr)
                                                  (push-reg-pair-on-stack cpu (gbcpu-h cpu) (gbcpu-l cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xe6) (make-instruction :opcode #xe6 :bytes 2 :cycles '(2 2) :asm '(:and "A,u8")
                                        :fun (lambda (cpu instr)
                                               (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                      (res (and-op cpu (gbcpu-a cpu) b)))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xe7) (make-instruction :opcode #xe7 :bytes 1 :cycles '(4 4) :asm '(:rst "20h")
                                        :fun (lambda (cpu instr)
                                                  (incr-cpu-counters cpu instr)
                                                    (do-rst cpu #x20))))
(setf (aref ops #xe8) (make-instruction :opcode #xe8 :bytes 2 :cycles '(2 2) :asm '(:add "SP,i8")
                                        :fun (lambda (cpu instr)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-sp cpu) (add-signed-byte-to-sp cpu b))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xe9) (make-instruction :opcode #xe9 :bytes 1 :cycles '(1 0) :asm '(:jp "HL")
                                        :fun (lambda (cpu instr)
                                                    (do-jump cpu (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu))))))
(setf (aref ops #xea) (make-instruction :opcode #xea :bytes 3 :cycles '(4 4) :asm '(:ld "(u16),A")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (write-memory-at-addr addr (gbcpu-a cpu))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xee) (make-instruction :opcode #xee :bytes 2 :cycles '(2 2) :asm '(:xor "A,u8")
                                        :fun (lambda (cpu instr)
                                               (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                      (res (xor cpu (gbcpu-a cpu) b)))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xef) (make-instruction :opcode #xef :bytes 1 :cycles '(4 4) :asm '(:rst "28h")
                                        :fun (lambda (cpu instr)
                                                  (incr-cpu-counters cpu instr)
                                                    (do-rst cpu #x28))))

(setf (aref ops #xf0) (make-instruction :opcode #xf0 :bytes 2 :cycles '(3 3) :asm '(:ld "A,(FF00+u8)")
                                        :fun (lambda (cpu instr)
                                                (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                         (addr (+ #xff00 b)))
                                                  (setf (gbcpu-a cpu) (aref memory addr))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xf1) (make-instruction :opcode #xf1 :bytes 1 :cycles '(3 3) :asm '(:pop "AF")
                                        :fun (lambda (cpu instr)
                                                  (set-reg-pair-af-to-val cpu (pop-addr-from-stack cpu))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xf2) (make-instruction :opcode #xf2 :bytes 1 :cycles '(2 2) :asm '(:ld "A,(FF00+C)")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (+ #xff00 (gbcpu-c cpu))))
                                                  (setf (gbcpu-a cpu) (aref memory addr))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xf3) (make-instruction :opcode #xf3 :bytes 1 :cycles '(1 1) :asm '(:di)
                                        :fun (lambda (cpu instr)
                                               (format t "interrupts disabled~%")
                                               (setf (gbcpu-int-ena cpu) 0)
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #xf5) (make-instruction :opcode #xf5 :bytes 1 :cycles '(4 4) :asm '(:push "AF")
                                        :fun (lambda (cpu instr)
                                                  (push-reg-pair-on-stack cpu (gbcpu-a cpu) (flags-into-byte (gbcpu-flags cpu)))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref ops #xf6) (make-instruction :opcode #xf6 :bytes 2 :cycles '(2 2) :asm '(:or "A,u8")
                                        :fun (lambda (cpu instr)
                                               (let* ((b (aref memory (+ (gbcpu-pc cpu) 1)))
                                                      (res (or-op cpu (gbcpu-a cpu) b)))
                                                  (setf (gbcpu-a cpu) res)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xf7) (make-instruction :opcode #xf7 :bytes 1 :cycles '(4 4) :asm '(:rst "30h")
                                        :fun (lambda (cpu instr)
                                                  (incr-cpu-counters cpu instr)
                                                    (do-rst cpu #x30))))
(setf (aref ops #xf8) (make-instruction :opcode #xf8 :bytes 2 :cycles '(2 2) :asm '(:add "HL,SP+i8")
                                        :fun (lambda (cpu instr)
                                                (let ((b (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (set-reg-pair-hl-to-val cpu (add-signed-byte-to-sp cpu b))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xf9) (make-instruction :opcode #xf9 :bytes 1 :cycles '(2 2) :asm '(:ld "SP,HL")
                                        :fun (lambda (cpu instr)
                                               (setf (gbcpu-sp cpu) (get-address-from-reg-pair (gbcpu-h cpu) (gbcpu-l cpu)))
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #xfa) (make-instruction :opcode #xfa :bytes 3 :cycles '(4 4) :asm '(:ld "A,(u16)")
                                        :fun (lambda (cpu instr)
                                                (let ((addr (get-address-from-memory memory (+ (gbcpu-pc cpu) 1))))
                                                  (setf (gbcpu-a cpu) (aref memory addr))
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xfb) (make-instruction :opcode #xfb :bytes 1 :cycles '(1 1) :asm '(:ei)
                                        :fun (lambda (cpu instr)
                                               (format t "interrupts enabled~%")
                                               (setf (gbcpu-int-ena cpu) 1)
                                               (incr-cpu-counters cpu instr))))
(setf (aref ops #xfe) (make-instruction :opcode #xfe :bytes 2 :cycles '(2 2) :asm '(:cp "A,u8")
                                           :fun (lambda (cpu instr)
                                                  (let ((val (aref memory (+ (gbcpu-pc cpu) 1))))
                                                  (cp-reg-with-val cpu (gbcpu-a cpu) val)
                                                  (incr-cpu-counters cpu instr)))))
(setf (aref ops #xff) (make-instruction :opcode #xff :bytes 1 :cycles '(4 4) :asm '(:rst "38h")
                                        :fun (lambda (cpu instr)
                                                  (incr-cpu-counters cpu instr)
                                                    (do-rst cpu #x38))))

(defun test-bit-reg (cpu val bit-pos)
  (let ((res (logand val (ash #x01 bit-pos))))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 1)
    res))
(defun reset-bit-reg (cpu val bit-pos)
  (let ((res (logand val (logxor (ash #x01 bit-pos) #xff))))
    res))
(defun set-bit-reg (cpu val bit-pos)
  (let ((res (logior val (ash #x01 bit-pos))))
    res))

(defun rot-left-reg (cpu val)
  (let ((b7 (logand (ash val -7) #x01))
        (res (logand (logior (ash val 1) (gbflags-c (gbcpu-flags cpu))) #xff)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 0
          (gbflags-c (gbcpu-flags cpu)) b7)
    res))
(defun rot-right-reg (cpu val)
  (let ((b1 (logand val #x01))
        (res (logand (logior (ash val -1) (ash (gbflags-c (gbcpu-flags cpu)) 7)) #xff)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 0
          (gbflags-c (gbcpu-flags cpu)) b1)
    res))
(defun rot-left-c-reg (cpu val)
  (let* ((b7 (logand (ash val -7) #x01))
        (res (logand (logior (ash val 1) b7) #xff)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 0
          (gbflags-c (gbcpu-flags cpu)) b7)
    res))
(defun rot-right-c-reg (cpu val)
  (let* ((b1 (logand val #x01))
        (res (logand (logior (ash val -1) (ash b1 7)) #xff)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 0
          (gbflags-c (gbcpu-flags cpu)) b1)
    res))

(defun shift-left-into-carry (cpu val)
  (let ((b7 (logand (ash val -7) #x01))
        (res (logand (ash val -1) #xff)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 0
          (gbflags-c (gbcpu-flags cpu)) b7)
    res))
(defun shift-right-into-carry (cpu val)
  (let ((b1 (logand val #x01))
        (res (logand (ash val -1) #xff)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 0
          (gbflags-c (gbcpu-flags cpu)) b1)
    res))

(defun swap-reg (cpu val)
  (let* ((lsb (logand val #xf))
        (msb (logand (ash val -4) #xf))
        (res (logior (ash lsb 4) msb)))
    (setf (gbflags-z (gbcpu-flags cpu)) (if (= res #x00) #x01 #x00)
          (gbflags-n (gbcpu-flags cpu)) 0
          (gbflags-h (gbcpu-flags cpu)) 0
          (gbflags-c (gbcpu-flags cpu)) 0)
    res))

;; RLC
(setf (aref cb-ops #x01) (make-instruction :opcode #x01 :bytes 2 :cycles '(2 2) :asm '(:rlc "C")
                                           :fun (lambda (cpu instr)
                                                  (setf (gbcpu-c cpu ) (rot-left-c-reg cpu (gbcpu-c cpu)))
                                                  (incr-cpu-counters cpu instr))))
;; RRC
(setf (aref cb-ops #x09) (make-instruction :opcode #x09 :bytes 2 :cycles '(2 2) :asm '(:rrc "C")
                                           :fun (lambda (cpu instr)
                                                  (setf (gbcpu-c cpu ) (rot-right-c-reg cpu (gbcpu-c cpu)))
                                                  (incr-cpu-counters cpu instr))))
;; RL
(setf (aref cb-ops #x11) (make-instruction :opcode #x11 :bytes 2 :cycles '(2 2) :asm '(:rl "C")
                                           :fun (lambda (cpu instr)
                                                  (setf (gbcpu-c cpu ) (rot-left-reg cpu (gbcpu-c cpu)))
                                                  (incr-cpu-counters cpu instr))))
;; RR
(setf (aref cb-ops #x19) (make-instruction :opcode #x19 :bytes 2 :cycles '(2 2) :asm '(:rr "C")
                                           :fun (lambda (cpu instr)
                                                  (setf (gbcpu-c cpu ) (rot-right-reg cpu (gbcpu-c cpu)))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref cb-ops #x1a) (make-instruction :opcode #x1a :bytes 2 :cycles '(2 2) :asm '(:rr "D")
                                           :fun (lambda (cpu instr)
                                                  (setf (gbcpu-d cpu ) (rot-right-reg cpu (gbcpu-d cpu)))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref cb-ops #x1b) (make-instruction :opcode #x1b :bytes 2 :cycles '(2 2) :asm '(:rr "E")
                                           :fun (lambda (cpu instr)
                                                  (setf (gbcpu-e cpu ) (rot-right-reg cpu (gbcpu-e cpu)))
                                                  (incr-cpu-counters cpu instr))))
;; SLA
(setf (aref cb-ops #x21) (make-instruction :opcode #x21 :bytes 2 :cycles '(2 2) :asm '(:sla "C")
                                           :fun (lambda (cpu instr)
                                                  (setf (gbcpu-c cpu ) (shift-left-reg cpu (gbcpu-c cpu)))
                                                  (incr-cpu-counters cpu instr))))
;; SRA
(setf (aref cb-ops #x29) (make-instruction :opcode #x29 :bytes 2 :cycles '(2 2) :asm '(:sra "C")
                                           :fun (lambda (cpu instr)
                                                  (setf (gbcpu-c cpu ) (shift-right-reg cpu (gbcpu-c cpu)))
                                                  (incr-cpu-counters cpu instr))))
;; SWAP
(setf (aref cb-ops #x31) (make-instruction :opcode #x31 :bytes 2 :cycles '(2 2) :asm '(:swap "C")
                                           :fun (lambda (cpu instr)
                                                  (setf (gbcpu-c cpu ) (swap-reg cpu (gbcpu-c cpu)))
                                                  (incr-cpu-counters cpu instr))))
(setf (aref cb-ops #x37) (make-instruction :opcode #x37 :bytes 2 :cycles '(2 2) :asm '(:swap "(HL)")
                                           :fun (lambda (cpu instr)
                                                  (set-reg-pair-hl-to-val cpu (swap-reg cpu (get-byte-from-hl-address cpu)))
                                                  (incr-cpu-counters cpu instr))))
;; SRL
(setf (aref cb-ops #x38) (make-instruction :opcode #x38 :bytes 2 :cycles '(2 2) :asm '(:srl "B")
                                           :fun (lambda (cpu instr)
                                                  (setf (gbcpu-b cpu ) (shift-right-into-carry cpu (gbcpu-b cpu)))
                                                  (incr-cpu-counters cpu instr))))
;; BIT
(setf (aref cb-ops #x7c) (make-instruction :opcode #x7c :bytes 2 :cycles '(2 2) :asm '(:bit "7,H")
                                           :fun (lambda (cpu instr)
                                                  (incr-cpu-counters cpu instr)
                                                  (test-bit-reg cpu (gbcpu-h cpu) 7))))
;; RES
(setf (aref cb-ops #x80) (make-instruction :opcode #x80 :bytes 2 :cycles '(2 2) :asm '(:res "0,B")
                                           :fun (lambda (cpu instr)
                                                  (incr-cpu-counters cpu instr)
                                                  (reset-bit-reg cpu (gbcpu-b cpu) 0))))
;; SET
(setf (aref cb-ops #xc0) (make-instruction :opcode #xc0 :bytes 2 :cycles '(2 2) :asm '(:bit "0,B")
                                           :fun (lambda (cpu instr)
                                                  (incr-cpu-counters cpu instr)
                                                  (set-bit-reg cpu (gbcpu-b cpu) 0))))

(defun get-cb-instruction (cpu)
  (let* ((op (aref memory (+ (gbcpu-pc cpu) 1)))
        (instr (aref cb-ops op)))
      (if (instruction-p instr)
        instr
        (format t "Unimplemented CB instruction ~X @ ~X~%" op (gbcpu-pc cpu)))))
(defparameter halted-instr (make-instruction :opcode 0 :bytes 0 :cycles '(1 1) :asm '(:cpu "halted")
                                             :fun (lambda (cpu instr) (incr-clocks cpu instr))))
(defun emu-single-op (cpu op)
    (let ((instr (if (= (gbcpu-halted cpu) #x00) (if (= op #xcb) (get-cb-instruction cpu) (aref ops op)) (halted-intr))))
    (if (instruction-p instr)
      (progn (if (null (instruction-fun instr))
               (format t "Unable to run function for instruction ~X @ ~X~%" op (gbcpu-pc cpu))
               (funcall (instruction-fun instr) cpu instr))
             instr)
      (format t "Unimplemented instruction ~X @ ~X~%" op (gbcpu-pc cpu)))))

(defun do-interrupt (cpu interrupt-id)
  (setf (gbcpu-halted cpu) #x00)
  (write-memory-at-addr #xff0f (logand (read-memory-at-addr #xff0f) (logxor (ash #x01 interrupt-id) #xff)))
  (do-call-at-addr cpu (+ (* interrupt-id 8) #x40)))

(defun handle-interrupts (cpu)
  (if (= (gbcpu-int-ena cpu) #x01)
      ; VBLANK interupt
      (if (= (logand (logand (aref memory #xffff) #x01) (logand (aref memory #xff0f) #x01)) #x01)
        (do-interrupt cpu 0)
      ; LCDC Status interupt
      (if (= (logand (logand (aref memory #xffff) #x02) (logand (aref memory #xff0f) #x02)) #x02)
        (do-interrupt cpu 1)
      ; Timer interupt
      (if (= (logand (logand (aref memory #xffff) #x04) (logand (aref memory #xff0f) #x04)) #x04)
        (do-interrupt cpu 2)
      ; Serial Transfer interupt
      (if (= (logand (logand (aref memory #xffff) #x08) (logand (aref memory #xff0f) #x08)) #x08)
        (do-interrupt cpu 3)
      ; Hi-Lo of P10-P13 interupt
      (if (= (logand (logand (aref memory #xffff) #x10) (logand (aref memory #xff0f) #x10)) #x10)
        (do-interrupt cpu 4))))))))

(defun handle-timers (cpu)
  (if (> (gbcpu-div-clock cpu) #xff) (setf (gbcpu-div-clock cpu) (- (gbcpu-div-clock cpu) #x100)
                                           (aref memory #xff04) (logand (+ (aref memory #xff04) #x01) #xff)))
  (if (= (logand (read-memory-at-addr #xff07) #x04) #x04)
    (incr-timer-by-cycles cpu (get-cycles-per-timer-tick(get-timer-frequency)))
    (setf (gbcpu-clock cpu) 0)))

(defun incr-timer-by-cycles (cpu cycles-per-tick)
  (let* ((cycles (gbcpu-clock cpu))
         (ticks (floor cycles cycles-per-tick))
         (remainder (mod cycles cycles-per-tick))
         (cur-ticks (read-memory-at-addr #xff05))
         (new-ticks (+ cur-ticks ticks)))
    (setf (gbcpu-clock cpu) remainder)
    (if (> new-ticks #xff)
      (progn (write-memory-at-addr #xff0f (logior (read-memory-at-addr #xff0f) #x04))
             (write-memory-at-addr #xff05 (+ (read-memory-at-addr #xff06) (logand new-ticks #xff))))
    (write-memory-at-addr #xff05 (logand new-ticks #xff)))))

(defun get-cycles-per-timer-tick (freq)
  (/ CPU_SPEED freq))

(defun get-timer-frequency ()
  (let* ((freq-mem (read-memory-at-addr #xff07))
        (freq-mem-two-lsb (logand freq-mem #x3)))
    (if (= freq-mem-two-lsb #x01) 262144
      (if (= freq-mem-two-lsb #x02) 65536
        (if (= freq-mem-two-lsb #x03) 16384
          4096)))))


(defconstant CPU_SPEED 4194304)

(defparameter *out* ())
(defun emu-main (cpu)
  (loop for o = (aref memory (gbcpu-pc cpu))
        while (< (gbcpu-pc cpu) #xe000)
        ;while (not (= (gbcpu-pc cpu) #xCB35))
        for instr  = (emu-single-op cpu o)
        while instr
        do (when (instruction-p instr)
             (format t "~X: ~A --> PC=~X~%" (instruction-opcode instr) (instruction-asm instr) (gbcpu-pc cpu)))
        (if (= (aref memory #xff02) #x81) (setf *out* (cons (code-char (aref memory #xff01)) *out*)
                                                (aref memory #xff02) 0))
        (if (= (gbcpu-pc cpu) #x100) (replace-memory-with-rom loaded-rom))
        (handle-interrupts cpu)
        (handle-timers cpu)))

;(load "gbcpu.lisp")

(defparameter *cpu* (default-cpu))

;(replace-memory-with-rom "red.gb")

(defun dump-blargg-output ()
  (loop for a from #x9800 to #x9BFF
        do (format t "~A" (code-char (aref memory a)))))
(defun dump-out ()
  (format t "~{~A~}" (reverse *out*)))

;; test rom memory replace calls
(defparameter loaded-rom "~/repos/github/retrio/gb-test-roms/instr_timing/instr_timing.gb")
;(defparameter loaded-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/01-special.gb")
;(defparameter loaded-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/02-interrupts.gb")
;(defparameter loaded-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/03-op sp,hl.gb")
;(defparameter loaded-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/04-op r,imm.gb")
;(defparameter loaded-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/05-op rp.gb")
;(defparameter loaded-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/06-ld r,r.gb") ; PASSED
;(defparameter loaded-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/07-jr,jp,call,ret,rst.gb") ; PASSED
;(defparameter loaded-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/08-misc instrs.gb") ; PASSED
;(defparameter loaded-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/09-op r,r.gb")
;(defparameter loaded-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/10-bit ops.gb")
;(defparameter loaded-rom "~/repos/github/retrio/gb-test-roms/cpu_instrs/individual/11-op a,(hl).gb")

(replace-memory-with-rom loaded-rom)

(replace-memory-with-rom "DMG_ROM.bin")

(setf (aref memory #xff44) #x90)

(defun run () (emu-main *cpu*))

(emu-main *cpu*)

